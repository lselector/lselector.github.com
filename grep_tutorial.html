<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Description" content="Machine Learning, AI, Data Science, Python, Jupyter, Linux, Cloud, SQL">
   <meta name="GENERATOR" content="Mozilla/4.76 [en] (Windows NT 5.0; U) [Netscape]">
   <meta name="Author" content="Lev Selector">
   <title>grep_tutorial</title>
<!--



"Description" content="Machine Learning, AI, Data Science, Python, Jupyter, Linux, Cloud, SQL"



-->
<link REL="stylesheet" TYPE="text/css" HREF="style0.css" >
</head>
<body text="#000000" bgcolor="#FFFFFF">
<a NAME="top"></a>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><b><font color="#CC0000">LevSelector.com</font></b><spacer type=block width=1 height=1></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><spacer type=block width=1 height=1><b><font color="#CC0000">New
York</font></b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<tr>
<td><spacer type=block width=1 height=1></td>
</tr>

<tr>
<td BGCOLOR="#66CCFF"><spacer type=block width=1 height=1></td>
</tr>

<tr>
<td><spacer type=block width=1 height=1></td>
</tr>
</table>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" BGCOLOR="#C4ECFF" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><spacer type=block width=1 height=1><b><a href="index.html">home</a>
> grep</b></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><spacer type=block width=1 height=1><b></b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<tr>
<td><spacer type=block width=1 height=1></td>
</tr>

<tr>
<td BGCOLOR="#51C7FF"><spacer type=block width=1 height=1></td>
</tr>

<tr>
<td><spacer type=block width=1 height=1></td>
</tr>
</table>

<p><b><font color="#CC0000">grep tutorial</font></b>
<br><a NAME="intro"></a>
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" BGCOLOR="#C4ECFF" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><b>intro</b></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><b><a href="index.html">home</a> - <a href="#top">top
of the page</a> - </b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<p><font color="#6699CC">• </font><a href="http://www.engin.umich.edu/htbin/mangate?manpage=grep">www.engin.umich.edu/htbin/mangate?manpage=grep</a>
- grep manpage
<br>There are many tutorials and FAQs - search <b>google</b> for <b><a href="http://www.google.com/search?q=grep+tutorial">grep
tutorial</a></b> or <b><a href="http://www.google.com/search?hl=en&safe=off&q=grep+faq">grep
faq</a></b>
<p>grep basically searches.
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shell> grep foo
file(s)</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shell> grep foo
*</font>
<br>returns all the lines in file(s) that <i>contain</i> a string matching
the expression "foo" (which may be a regular expression).
<p>Another way of using <i>grep</i> is to have it accept data through STDIN
and filter to STDOUT. For example,
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shell> ls
|grep blah</font>
<br>lists all files in the current directory containing the string "blah"
<p><b><u>Some common option:</u></b>
<table BORDER=0 CELLSPACING=0 BGCOLOR="#FFFFCC" >
<tr>
<td><b><font color="#3333FF">-v</font></b>&nbsp;&nbsp; - invert (print
all lines except those that contain the pattern).
<br><b><font color="#3333FF">-i</font></b>&nbsp;&nbsp;&nbsp; - ignore case
of letters (small and capital treated as the same)
<br><b><font color="#3333FF">-l&nbsp;</font></b>&nbsp;&nbsp; - (list) -
print a list of the file names where mathes found
<br><b><font color="#3333FF">-s</font></b>&nbsp;&nbsp; - suppress error
messages about nonexistent or unreadable files.
<p>-c&nbsp;&nbsp; - print only a count of the lines that&nbsp; contain
the pattern.
<br>-n&nbsp;&nbsp; - precede each line by its line number&nbsp; in&nbsp;
the file (first line is 1).
<br>-h&nbsp;&nbsp; - prevents the name of the file containing&nbsp; the
matching&nbsp; line&nbsp; from&nbsp; being&nbsp; appended to that line
(used when searching multiple files).
<br>-w&nbsp; - search for the expression as&nbsp; a&nbsp; word&nbsp; as&nbsp;
if surrounded by \&lt; and \>.</td>
</tr>
</table>

<p><b><u>Example:</u></b> - find all cgi scripts in the directory which
calls certain stored procedure:
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ls | grep -i myproc</font>
<p><b><u>Example:</u></b> - count how many 'httpd' processes are running:
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps -ef | grep
httpd | wc</font>
<br><b><u>Example:</u></b> - pipe several greps to filter out things:
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ps -ef | grep&nbsp;
-v&nbsp; ^oracle | grep -v&nbsp; ^root | grep -v&nbsp; ^nobody</font>
<br><font color="#000000"><b><u>Example:</u></b> find all files in the
directory tree containing certain pattern:</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find . -type f
-print | xargs grep -ls 'your pattern' /dev/null/</font>
<br><b><u><font color="#000000">Commonly used find commands:</font></u></b>
<br><font color="#3333FF">find . -mtime -1 -print</font><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- find files modified in the last 24 hours</font>
<br><font color="#3333FF">find . -mtime -7 -name 'j*html'&nbsp; -print</font><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- find files modified no more than 7 days</font>
<br><font color="#3333FF">find . -name&nbsp; '*.pl'&nbsp; -exec perl -wc
{} \;</font>&nbsp;&nbsp;&nbsp; - compile many perl files at once
<p><b><u>Note:</u></b>&nbsp; in the example above that the patterns are
regular expressions. So the '^' means&nbsp; "match at the beginning of
the line".
<p><b><u>Example:</u></b>&nbsp; using dot (matches any character) and star
(tells that the preceding character may be 0 or more times):
<table BORDER=0 CELLSPACING=0 CELLPADDING=4 BGCOLOR="#FFFFCC" >
<tr BGCOLOR="#FFCC99">
<td VALIGN=TOP>The File for These Examples</td>

<td VALIGN=TOP>Wildcards #1</td>

<td VALIGN=TOP>Wildcards #2</td>

<td VALIGN=TOP>Wildcards #3</td>
</tr>

<tr>
<td ALIGN=LEFT VALIGN=TOP>>cat file
<br>big
<br>bad bug&nbsp;
<br>bag
<br>bigger
<br>boogy</td>

<td ALIGN=LEFT VALIGN=TOP>>grep b.*g file
<br>big
<br>bad bug&nbsp;
<br>bag
<br>bigger
<br>boogy</td>

<td ALIGN=LEFT VALIGN=TOP>>grep b.*g. file
<br>bigger
<br>boogy</td>

<td ALIGN=LEFT VALIGN=TOP>>grep ggg* file
<br>bigger</td>
</tr>
</table>

<p><b><u>Note:</u></b>&nbsp; If the pattern consists of several words -
grep will think that the 2nd word is a file name.&nbsp; So you need to
surround the whole pattern with single quotes.&nbsp; You may want to use
double quotes if you want shell to expand the meaning of variables, for
example:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grep "$HOME" file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- searches file for the name of your home directory
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grep '$HOME' file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- searches for the string $HOME
<p><b><u>Note:</u></b>&nbsp; If the pattern contains '$' or some other
special characters ( ?&nbsp; \&nbsp; .&nbsp; [&nbsp; ]&nbsp; ^&nbsp; $
) - shell will interpret them before passing them to grep.&nbsp; To avoid
this, you need to escape them with backslashes. Also some characters may
have special meaning to grep itself (like dot or '^'). If you want just
the character itself - you need to escape with backslash. You use escapes
inside single-quoted pattern.
<p><b><u>Example:</u></b>
<br>&nbsp;&nbsp;&nbsp;&nbsp; grep 'hello\.gif' file&nbsp;&nbsp;&nbsp; -
matches hello.gif
<br>&nbsp;&nbsp;&nbsp;&nbsp; grep 'hello.gif' file&nbsp;&nbsp;&nbsp;&nbsp;
- matches lines containing hello-gif , hello1gif , helloagif , etc.
<p><b><u>Example:</u></b> using '?' (means 'may be one'):
<br>&nbsp;&nbsp;&nbsp;&nbsp; grep 'bugg\?y' file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&nbsp; matches all of the following: bugy , buggy but not bugggy
<br>&nbsp;&nbsp;&nbsp;&nbsp; grep 'Fred\(eric\)\? Smith' file&nbsp;&nbsp;&nbsp;&nbsp;
- matches Fred Smith or Frederic Smith
<p>Other regex constructs:
<br>&nbsp;&nbsp;&nbsp; grep '\(abc\)*' file&nbsp;&nbsp;&nbsp; - matches
abc , abcabcabc etc. (i.e. , any number of repetitions of the string abc
, including the empty string.)
<br>&nbsp;&nbsp;&nbsp; grep [Hh]ello&nbsp; file&nbsp;&nbsp;&nbsp; - matches
lines containing hello or Hello
<p>Ranges:
<br>&nbsp;&nbsp;&nbsp; [0-3]&nbsp;&nbsp; is the same as&nbsp;&nbsp; [0123]
<br>&nbsp;&nbsp;&nbsp; [a-k]&nbsp;&nbsp; is the same as&nbsp;&nbsp; [abcdefghijk]
<br>&nbsp;&nbsp;&nbsp; [A-C] is the same as [ABC]
<br>&nbsp;&nbsp;&nbsp; [A-Ca-k] is the same as [ABCabcdefghijk]
<br>There are also some alternate forms :
<br>&nbsp;&nbsp;&nbsp; [[:alpha:]] is the same as [a-zA-Z]
<br>&nbsp;&nbsp;&nbsp; [[:upper:]] is the same as [A-Z]
<br>&nbsp;&nbsp;&nbsp; [[:lower:]] is the same as [a-z]
<br>&nbsp;&nbsp;&nbsp; [[:digit:]] is the same as [0-9]
<br>&nbsp;&nbsp;&nbsp; [[:alnum:]] is the same as [0-9a-zA-Z]
<br>&nbsp;&nbsp;&nbsp; [[:space:]] matches any white space including tabs
<p>The [] may be used to search for <i>non-matches</i>. This is done by
putting a '^' as a first character inside the square brackets.
<br><b><u>Example:</u></b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grep "([^()]*)a" file&nbsp;&nbsp;&nbsp;&nbsp;
-&nbsp; returns any line containing a pair of parentheses that are innermost
(don't have parenthesis inside them) and are followed by the letter "a".
So it matches these lines
<br>&nbsp;&nbsp; (hello)a
<br>&nbsp;&nbsp; (aksjdhaksj d ka)a
<br>But not this
<br>&nbsp;&nbsp;&nbsp; x=(y+2(x+1))a
<p><b><u>Note:</u></b>
<br>&nbsp; A closing square bracket loses its special meaning if placed
first in a list. For example []12] matches ] , 1, or 2.
<br>&nbsp; A dash - loses it's usual meaning inside lists if it is placed
last.
<br>&nbsp; A carat ^ loses it's special meaning if it is not placed first
<br>&nbsp; Most special characters lose their meaning inside square brackets
<br>&nbsp; Note that a $ sign loses its meaning if characters follow it
<p><b><u>Matching a Specific Number Of Repetitions of a Pattern:</u></b>
<br>Example: searching for a 7 digit phone number like this:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grep "[:digit:]\{3\}[ -]\?[:digit:]\{4\}"
file
<br>This matches phone numbers, possibly containing a dash or whitespace
in the middle.
<p><i>The $ character matches the end of the line. The ^ character matches
the beginning of the line.</i>
<br><b><u>Example:</u></b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grep "^[[:space:]]*hello[[:space:]]*$"
file
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grep "^From.*somename" /var/spool/mail/myname&nbsp;&nbsp;&nbsp;
- searches mail inbox for headers from a particular person.
<p>Vertical line means 'either this or that':
<br><b><u>Example:</u></b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grep "cat\|dog"&nbsp;&nbsp;&nbsp; -
file matches lines containing the word "cat" or the word "dog"
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grep "I am a \(cat\|dog\)" matches lines
containing the string "I am a cat" or the string "I am a dog".
<p><b><u>Backreferences</u></b>
<br>The expression &lt;H[1-6]>.*&lt;/H[1-6]> is not good enough to match
html headers, since it matches &lt;H1>Hello world&lt;/H3> (Error here -
opening tag is different from the closing one). Solution - use a <i>backreference</i>
<br><font color="#CC0000">Backreference is an expression \n where n is
a number.&nbsp; It matches the contents of the n'th set of parentheses
in the expression.</font>
<p><b><u>Examples:</u></b>
<br>&lt;H\([1-6]\).*&lt;/H\1> matches what we were trying to match before.
<br>"Mr \(dog\|cat\) came home to Mrs \1 and they went to visit Mr \(dog\|cat\)
and Mrs \2 to discuss the meaning of life matches"
<br>&nbsp;
<p><b><u>egrep</u></b>
<br>despite the origin of the name (extended), egrep actually has <i>less</i>
functionality as it is designed for compatibility with the traditional
egrep. A better way to do an extended "grep" is to use grep -E which uses
extended regular expression syntax without loss of functionality.
<table BORDER CELLSPACING=0 CELLPADDING=4 BGCOLOR="#FFFFCC" >
<tr BGCOLOR="#FFCC99">
<td>grep</td>

<td>grep -E</td>

<td>Available for egrep?</td>
</tr>

<tr>
<td>a\+</td>

<td>a+</td>

<td>yes</td>
</tr>

<tr>
<td>a\?</td>

<td>a?</td>

<td>yes</td>
</tr>

<tr>
<td>expression1\|expression2</td>

<td>expression1|expression2?</td>

<td>yes</td>
</tr>

<tr>
<td>\(expression\)</td>

<td>(expression1)</td>

<td>yes</td>
</tr>

<tr>
<td>\{m,n\}</td>

<td>{m,n}</td>

<td>no</td>
</tr>

<tr>
<td>\{,n\}</td>

<td>{,n}</td>

<td>no</td>
</tr>

<tr>
<td>\{m,}</td>

<td>{m,}</td>

<td>no</td>
</tr>

<tr>
<td>\{m}</td>

<td>{m}</td>

<td>no</td>
</tr>
</table>

<p>----------------------
<p>This page adapted from <a href="http://www.pegasus.rutgers.edu/~elflord/unix/grep.html">http://www.pegasus.rutgers.edu/~elflord/unix/grep.html</a>
</body>
</html>
