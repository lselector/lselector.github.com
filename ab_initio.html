<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Description" content="Description" content="Machine Learning, AI, Data Science, Python, Jupyter, Linux, Cloud, SQL">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; U) [Netscape]">
   <meta name="Author" content="Lev Selector">
   <title>Ab Initio</title>
<!--

"Description" content="Machine Learning, AI, Data Science, Python, Jupyter, Linux, Cloud, SQL"

-->
<link REL="stylesheet" TYPE="text/css" HREF="style0.css" >
<style type="text/css">
<!--
.style1 {
	color: #CC0000;
	font-weight: bold;
}
.code {color: #0000FF}
.comment {color: #669900}
-->
</style>
</head>
<body text="#000000" bgcolor="#FFFFFF">
<a NAME="top"></a>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><b><font color="#CC0000">LevSelector.com</font></b><spacer type=block width=1 height=1></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><spacer type=block width=1 height=1><b><font color="#CC0000">New
York</font></b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<tr>
<td><spacer type=block width=1 height=1></td>
</tr>

<tr>
<td BGCOLOR="#66CCFF"><spacer type=block width=1 height=1></td>
</tr>

<tr>
<td><spacer type=block width=1 height=1></td>
</tr>
</table>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" BGCOLOR="#C4ECFF" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><spacer type=block width=1 height=1>
<b><a href="index.html">home</a>
> Ab Initio</b></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><spacer type=block width=1 height=1><b></b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<tr>
<td><spacer type=block width=1 height=1></td>
</tr>

<tr>
<td BGCOLOR="#51C7FF"><spacer type=block width=1 height=1></td>
</tr>

<tr>
<td><spacer type=block width=1 height=1></td>
</tr>
</table>

<p><b><font color="#CC0000">Ab Initio</font></b>

<table width="95%" border="0" cellpadding="3" cellspacing="0">
  <tr>
    <td><span class="style1">On This Page</span></td>
    <td class="style1">Other Pages</td>
  </tr>
  <tr>
    <td valign="top">
    <p>
- <a href="#intro">intro</a><br>
<br>
    </p>    </td>
    <td valign="top">
    <p>
- <a href="#xx">xx</a><br>
<br>
    </p>    </td>
  </tr>
</table>
  <p class="sectionheader"><a NAME="intro"></a>Intro ------------------------------</p>
  <p>The Latin term <span class="style1">ab initio</span> means <span class="style1">from the beginning</span> .</p>
  <p>&quot;Ab Initio Software LLC&quot; is a  company which excels in solving extreme data processing problems.</p>
  <p>Many  IT people never heard of Ab Initio. Why? Well, first, Ab Initio never advertise themselves. They get lots of business by referral - in fact so much that they don't need any advertising. Second, because Ab Initio only works with few clients who have extreme data processing problems. Ab Initio is not common, and they don't sell software. They  sell solutions - and license the tools to provide those solutions. So it is more a solutions company, not a software company. </p>
<p>Most of those people who have heard about Ab Initio think about it as an ETL provider. This is wrong. Yes, Ab Initio has excellent tools for ETL (Extract, Transform, Load). But for some problems they provide solutions which have nothing to do with databases. In fact, in many situations they recommend to STOP using database at all for performance reasons.</p>
  <p>If you are a small or medium client - Ab Initio is an overkill. But if you have thousands of transactions per second, big databases,  very active web site, or huge transactional or accounting system - Ab Initio is a savior. Their pricing model is a bit unusual, but the long term costs are reasonable. </p>
  <p>You can read a short description on wikipedia, but as of today (20098) this description doesn't give a good honest representation of the company (in my opinion).</p>
  <ul>
    <li><a href="http://en.wikipedia.org/wiki/Ab_Initio">http://en.wikipedia.org/wiki/Ab_Initio</a></li>
    <li><a href="http://www.abinitio.com">http://www.abinitio.com</a></li>
    <li><a href="http://www.patents.com/Ab-Initio-Software-Corporation/Lexington/MA/301339/company/">http://www.patents.com/Ab-Initio-Software-Corporation/Lexington/MA/301339/company/</a></li>
    <li><a href="http://www.bi-nerd.com/ab-initio-the-dark-horse-of-etl/">http://www.bi-nerd.com/ab-initio-the-dark-horse-of-etl/</a></li>
    <li>Patents: <a href="AbInitio/US6654907.pdf" target="_blank">US6654907.pdf</a>, <a href="AbInitio/US7047232.pdf" target="_blank">US7047232.pdf</a>, <a href="AbInitio/US7164422.pdf" target="_blank">US7164422.pdf</a>, <a href="AbInitio/US7167850.pdf" target="_blank">US7167850.pdf</a></li>
    <li><a href="http://www.linkedin.com/companies/ab-initio">http://www.linkedin.com/companies/ab-initio</a></li>
  </ul>
<p>Ab Initio is a private company, its main offices are in Lexington, Massachusetts (near Boston, USA - since 1994), but they have offices all over the world (as you can see on their web site). They have very good talented devoted people. I've heard that when you are calling their customer service - there is a 75% chance that you will speak with a Ph.D.. It may very well be true. The company was formed  by former employees of the <a href="http://www.inc.com/magazine/19950915/2622.html">Thinking Machines Corporation</a>. Some key people: Craig W. Stanfill,  Richard A. Shapiro, Stephen A. Kukolich.</p>
<p>Ab Initio also uses its own people as well as independent consulting firms to build proof of concept for a client, and then to guide clients in using their tools.</p>
<p>Unfortunately Ab Initio provides very little information about their solutions to general public. So not getting into details, most of AI functionality can be scripted using several commands which you can give from prompt (with many options):</p>
<ul>
  <li><span class="style1">m_*</span> commands ( for example, m_shutdown, m_mkfs, 
    m_cp, etc. ) are used for administering</li>
  <li><span class="style1">mp</span> ... (some options) - to define, establish, and run jobs</li>
  <li><span class="style1">air</span> ... (some options) - to work with EME (basically a specialized version control system)</li>
</ul>
<p>The scripts can be easily integrated to work with external schedulers.</p>
<p>Somewhere ~1997 Ab Initio has introduced  Graphical Development Environment - a very powerful desktop software. You place components on the screen, connect them, define what they do and how. So your application is a graph. You can create components which consist of other components which consist of other components, etc. - so effectively you can drill deeply into the diagram. I've seen this tool generating powerful data processing application in less than 10 minutes. You can run the application right from the IDE, or save it as a set of scripts (ksh for unix). The scripts will call misc. component libraries. The libraries are written in C++. </p>
<p>Some of the key elements of the system:</p>
<ul>
    <li> &quot;Co&gt;Operating System&quot;</li>
    <li>&quot;Component Library&quot;</li>
    <li>&quot;Graphical Development Environment&quot; (GDE)</li>
    <li>&quot;Enterprise Meta&gt;Environment&quot; (EME)</li>
    <li>&quot;Data Profiler&quot;</li>
    <li>&quot;Conduct&gt;It&quot;</li>
  </ul>
  <p>Main power of Ab Initio - parallelism - is achieved via its &quot;Co&gt;Operating System&quot; which provides the facilities for &quot;parallel execution (multiple CPUs and/or multiple boxes), platform independent data 
  transport, check pointing, and process monitoring. A lot of attention is devoted to monitoring resources (CPU, memory). multi-file, multi-directory.</p>
  <p>Component Library -  a set of software 
    modules to perform sorting, data transforming, and high speed 
  data loading and unloading tasks.</p>
  <p>Here are some of the main components  </p>
  <table border="1" cellspacing="0" cellpadding="5">
    <tr bgcolor="#FFCCCC">
      <td width="20%">Component Group</td>
      <td>Component</td>
    </tr>
    <tr>
      <td width="20%" valign="top" bgcolor="#CCFFCC">1.Dataset Components</td>
      <td valign="top" bgcolor="#FFFFCC"><p>        input file<br>
        output file<br>
        lookup file<br>
      intermediate file</p></td>
    </tr>
    <tr>
      <td valign="top" bgcolor="#CCFFCC"><p>2.Database Components<br>
      </p>
      <p></p></td>
      <td valign="top" bgcolor="#FFFFCC">input table<br>
output table<br>
run sql</td>
    </tr>
    <tr>
      <td valign="top" bgcolor="#CCFFCC"><p>3.Partition Components<br>
      </p>
      <p></p></td>
      <td valign="top" bgcolor="#FFFFCC">by key<br>
by round-robin<br>
by expression<br>
by range<br>
with load-balance</td>
    </tr>
    <tr>
      <td valign="top" bgcolor="#CCFFCC"><p>4.De-Partition Components<br>
      </p>
      <p></p></td>
      <td valign="top" bgcolor="#FFFFCC">concatenate<br>
interleave (round-robin)<br>
merge<br>
gather (arbitrary)</td>
    </tr>
    <tr>
      <td valign="top" bgcolor="#CCFFCC"><p>5.Sort Components<br>
      </p></td>
      <td valign="top" bgcolor="#FFFFCC"><p>sort<br>
        sort within groups<br>
        partition by key and sort<br>
        dedup sorted<br>
      checkpoint Sort</p></td>
    </tr>
    <tr>
      <td valign="top" bgcolor="#CCFFCC">6.Transform Components<br></td>
      <td valign="top" bgcolor="#FFFFCC">filter<br>
join<br>
reformat<br>
rollup<br>
aggregate<br>
scan</td>
    </tr>
  </table>
  <p>Graphical interface allows to create workflows by combining multiple components, for example:</p>
  <p><img src="images/abinitio_graph.png" width="348" height="243" alt="Ab Initio Graph Example"></p>
  <p>You can add components to a graph, click on components to configure them. You can use a graph as a reusable subgraph to include into other graphs. The lines between components may represent sequential or parallel flows of data.</p>
  <p>Ab Initio tools incorporate best practices, such as check-pointing, rerunnability, tagging everything with unique Id-s, etc.</p>
<p>One interesting concept is 
  ICFF - indexed compressed flat file (ICFF).</p>
  <table width="90%" border="1" cellspacing="0" cellpadding="2">
    <tr>
      <td bgcolor="#FFFF66"><p>ICFF =  Indexed Compressed Flat Lookup File.<br>
        this file can do fast effective lookups. (Note: index is a hash.)     </p>
        <p>Components:<br>
        Write Block Compressed Lookups<br>
        Write Multiple Block Compressed lookups<br>
- compresses data into blocks, indexes blocks, writes them out into file(s).</p>
        <p>        Lookup function: 
        search index, finds block(s), read blocks from disk, uncompresses, searches inside the block for matching record(s).</p>
        <p>ICFF take 10-times less disk space than normal uncompressed lookup files. Lookup time is fast.</p>
        <p><br>
      </p></td>
    </tr>
  </table>
  <p><br>
  Unfortunately Ab Initio doesn't advertise or publish any information. <br>
  So there are just bits and pieces here and there. Here is an interesting blog:</p>
<ul>
  <li><a href="http://www.geekinterview.com/Interview-Questions/Data-Warehouse/Abinitio">http://www.geekinterview.com/Interview-Questions/Data-Warehouse/Abinitio</a></li>
</ul>
<p>1</p>
<table width="98%" border="1" cellspacing="0" cellpadding="5">
  <tr bgcolor="#FFCCCC">
    <td width="20%">Question</td>
    <td>Answer ==========================================================</td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">Phases vs Checkpoints</td>
    <td bgcolor="#FFFFCC"><p>Phases - are used to break the graph into pieces. Temporary files created during a phase will be deleted after its completion. Phases are used to effectively separately manage resource-consuming (memory, CPU, disk) parts of the application.</p>
      <p>Checkpoints - created for recovery purposes. These are points where everything is written to disk. You can recover to the latest saved point - and rerun from it. </p>
      <p> You can have phase breaks with or without checkpoints.<br>
    </p></td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">xfr</td>
    <td bgcolor="#FFFFCC"><p>A new sandbox will have many directories: mp, dml, xfr, db, ... . xfr is a directory where you put files with extension .xfr containing your own custom functions (and then use : include &quot;somepath/xfr/yourfile.xfr&quot;). Usually XFR stores mapping.</p>    </td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">three types of parallelism</td>
    <td bgcolor="#FFFFCC"><p>1) Data Parallesim - data (partitionning of data into parallel streams for parallel processing).</p>
      <p>2) Componnent Paralelism  (execute simultaneously on different branches of the graph)</p>
      <p>    3) Pipeline (sequential).</p></td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">MFS</td>
    <td bgcolor="#FFFFCC"><p>Multi-File System</p>
    <p>m_mkfs - create a multifile (m_mkfs ctrlfile mpfile1 ... mpfileN)<br>
    m_ls - list all the multifiles<br>
      m_rm - remove the multifile<br>
    m_cp - copy a multifile</p>
    <p>m_mkdir - to add more directories to existing directory structure</p></td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">Memory requirements of a graph</td>
    <td bgcolor="#FFFFCC"><ul>
      <li> Each partition of a component uses: 
        ~ 8 MB + max-core (if any) </li>
      <li>   Add size of lookup files used in phase (if multiple components use same lookup   only count it once)</li>
      <li> Multiply by degree of parallelism. Add up all   components in a phase; that is how much memory is used in that phase.</li>
      <li>Select the  largest-memory phase in the   graph</li>
    </ul></td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">How to calculate a SUM</td>
    <td bgcolor="#FFFFCC"><p>SCAN<br>
      ROLLUP<br>
    SCANWITHROLLUP<br>
     Scan followed by Dedup sort and select the last <br>
    </p>    </td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">dedup sort with null key</td>
    <td bgcolor="#FFFFCC"><p>        If we don't use any key  in the sort component while using the dedup sort,<br> 
      then the output depends on the keep parameter.</p>
      <ul>
        <li>        first -  only the first record </li>
        <li>         last - only last record </li>
        <li>         unique_only - there will be no  records in the output file.<br>
          <br>
        </li>
    </ul></td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">join on partitioned flow</td>
    <td bgcolor="#FFFFCC">file1 (A,B,C) , file2 (A,B,D). We partition both files by &quot;A&quot;, and then join by &quot;A,B&quot;. IS it OK? Or should we partition by &quot;A,B&quot; ? Not clear.</td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">checkin, checkout</td>
    <td bgcolor="#FFFFCC">You can do checkin/checkout using the wizard right from the GDE using versions and tags</td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">how to have different passwords for QA and production</td>
    <td bgcolor="#FFFFCC">parameterize the .dbc file - or use environmental variable.</td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">How to get records 50-75 out of 100</td>
    <td bgcolor="#FFFFCC"><ul>
      <li>use scan and filter</li>
      <li>m_dump &lt;dml&gt; &lt;mfs file&gt; -start 50 -end 75</li>
      <li>use next_in_sequence() function and filter by expression component (next_in_sequence() &gt;50 &amp;&amp; next_in_sequence() &lt;75)</li>
      </ul>    </td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">Hot to convert a serial file into FFS</td>
    <td bgcolor="#FFFFCC">create MFS, then use partition component</td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">project parameters vs. sandbox parameters</td>
    <td bgcolor="#FFFFCC"><p>When you check out a project into your sandbox - you get project parameters. Once in your sandbox - you can refer to them as sandbox parameters.<br>
      </p>    </td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">Bad-Straight-flow</td>
    <td bgcolor="#FFFFCC">error you get when connecting mismatching components (for example, connecting serial flow directly to  mfs flow without using a partition component)</td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">merging graphs</td>
    <td bgcolor="#FFFFCC"><p>You can not merge two ab initio graphs. You can use the ouput of one graph as input for another. You can also  copy/paste the contents between graphs. See also about using .plan</p>    </td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">partitioning, re-partitioning, departitioning</td>
    <td bgcolor="#FFFFCC"><ul>
      <li>partitioning - dividing a single flow of records(serial file, mfs) into multiple flows.</li>
      <li>departitioning - removing partitionning (gather an merge component)</li>
      <li>re-partitioning - change the number of partitions (eg, from 2 to 4 flows)<br>
      </li>
    </ul></td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">lookup file</td>
    <td bgcolor="#FFFFCC">for large amounts of data use MFS lookup file (instead of serial)</td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">indexing</td>
    <td bgcolor="#FFFFCC">No indexes as such. But there is an &quot;output indexing&quot; using reformat and doing necessary coding in transform part.</td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">Environment project</td>
    <td bgcolor="#FFFFCC">Environment project - special public project that exists in every Ab Initio environment. It contains all the environment parameters required by the private or public projects which constitute AI Standard Environment. <br></td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">Aggregate vs Rollup</td>
    <td bgcolor="#FFFFCC">Aggregate - old component<br>
Rollup - newer, extended, recommended to use instead of Agregate.<br>
(built-in functions like sum count avg min max product, ...)</td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">EME, GDE, Co-operating sytem</td>
    <td bgcolor="#FFFFCC"><ul>
      <li>EME = Enterprise Metdata Environment. Functions (repository,  version control, statistical analysis, dependency analysis). It is on the server side and holds  all the projects (metadata of transformations, 
        config info, source and target info: graph dml xfr ksh sql, etc..). This is where you checkin/checkout. /Project dir of EME contains common directories for all application sandboxes connected to it. It also helps in dependency analysis of codes. Ab Initio has series of air commands to manipulate repository objects.</li>
        <li>GDE = Graphical Devlopment Environment (on the client box)</li>
        <li>Co-operating sytem = Ab Initio server installed on top of native (unix) os on the server</li>
      </ul>    </td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">fencing</td>
    <td bgcolor="#FFFFCC"><p>fencing means job controlling on priority basis.<br>
      In AI it actually refers to customized phase breaking. A well fenced graph means no matter what is source data volume process will not cough in dead locks. It actually limits the number of simultaneous processes.</p>
      <p>Fencing - changing a priority of a job<br>
        Phasing - managing the resources to avoid deadlocks.<br>
        For example, limiting the number of simultaneous processes<br>
    (by breaking the graph into phases, only 1 of which can run at any given time)</p></td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">Continuous components</td>
    <td bgcolor="#FFFFCC">Continuous components - produce useful output file while running continously. For example, Continuous rollup, Continuous update batch subscribe</td>
  </tr>
</table>
<p>2</p>
<table width="98%" border="1" cellspacing="0" cellpadding="5">
  <tr bgcolor="#FFCCCC">
    <td width="20%">Question</td>
    <td>Answer ==========================================================</td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">deadlock</td>
    <td bgcolor="#FFFFCC">Deadlock is when two or more processes are requesting the same  resource. To avoid use phasing and resource pooling.<br></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">environment</td>
    <td bgcolor="#FFFFCC"><ul>
      <li>AB_HOME - where co&gt;operating system is installed</li>
      <li> AB_AIR_ROOT - default location for EME datastore</li>
      <li>sandboxes standard environment</li>
      <li>AI_SORT_MAX_CORE, AI_HOME, AI_SERIAL, AI_MFS, etc.</li>
      <li>from unix prompt: env | grep AI</li>
    </ul></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">wrapper script</td>
    <td bgcolor="#FFFFCC">unix script to run graphs</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">multistage component</td>
    <td bgcolor="#FFFFCC">A multistage component is a component which transforms input records in 5 stages (1.input select, 2.temporary initialization, 3.processing, 4. output selection, 5.finalize). So it is a transform component which has packages. Examples: scan Normalize and Denormalize, rollup scan normalize and denormalize sorted. </td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Dynamic DML</td>
    <td bgcolor="#FFFFCC"><p>Dynamic DML is used if the input metadata can change. Example:  at different time different input files are recieved for processing which have different dml. in that case we can use flag in the dml and the flag is first read in the input file recieved and according to the flag its corresponding dml is used.</p>      </td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">fan in, fan out</td>
    <td bgcolor="#FFFFCC"><ul>
      <li>fan out - partition component (increase parallelism)</li>
      <li>fan in departition component (decrease parallelism) </li>
    </ul></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">lock</td>
    <td bgcolor="#FFFFCC">a user can lock the graph for editing so that others will see the message and can not edit the same graph.</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">join vs lookup</td>
    <td bgcolor="#FFFFCC">Lookup is good for spped for small files (will load whole file in memory). For large files use join. You may need to increase the maxcore limit to handle big joins.</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">multi update</td>
    <td bgcolor="#FFFFCC"><p>multi update executes SQL statements - it treats each input record as a completely separate piece of work.</p>    </td>
  </tr>
<tr>
    <td bgcolor="#CCFFCC">scheduler</td>
    <td bgcolor="#FFFFCC"><ul>
      <li>We can use Autosys, Control-M, or any other external scheduler. </li>
      <li>We can take care of dependencies in many ways. For example, if scripts should run sequentially, we can arrange for this in Autosys, or we can create a wrapper script and put there several sequential commands (nohup command1.ksh &amp; ; nohup command2.ksh &amp;; etc). We can even create a special graph in Ab Initio to execute individual scripts as needed.</li>
    </ul></td>
  </tr>
<tr>
  <td bgcolor="#CCFFCC"><p>Api and Utility modes in input table</p>    </td>
  <td bgcolor="#FFFFCC">These are database interfaces (api - uses SQL, utility - bulk loads, whatever vendor provides)</td>
</tr>
<tr>
  <td bgcolor="#CCFFCC">lookup file</td>
  <td bgcolor="#FFFFCC"><ul>
    <li>lookup file component. Functions: lookup, 
      lookup_count, 
      lookup_next, 
      lookup_match, 
      lookup_local.</li>
    <li>Lookups are always used with combination of the reformat components.</li>
  </ul></td>
</tr>
<tr>
  <td bgcolor="#CCFFCC">Calling stored proc in DB</td>
  <td bgcolor="#FFFFCC">You can call stored proc (for example, from input component). In fact, you can even write SP in Ab Initio. Make it &quot;with recompile&quot; to assure good performance.</td>
</tr>
<tr>
  <td bgcolor="#CCFFCC">Frequently used functions</td>
  <td bgcolor="#FFFFCC"><p>string_ltrim, string_lrtrim, string_substring, reinterpret_as, today(), now() </p>    </td>
</tr>
<tr>
  <td bgcolor="#CCFFCC">data validation</td>
  <td bgcolor="#FFFFCC">is_valid,  is_null, is_blank,  is_defined</td>
</tr>
<tr>
  <td bgcolor="#CCFFCC">driving port</td>
  <td bgcolor="#FFFFCC">When joining inputs (in0, in1, ...) one of the ports is used as &quot;driving (by default - in0). Driving input is usually the largest one. Whereas the smallest can have &quot;Sorted-Input&quot; parameter be set to &quot;Input need not be sorted&quot; because it will be loaded completely in memory.</td>
</tr>
<tr>
  <td bgcolor="#CCFFCC">Ab Initio vs Informatica for ETL</td>
  <td bgcolor="#FFFFCC"><p>Ab Initio benefits:  parallelism built in, mulitifile system, handles huge amounts of data, easy to build and run. Generates scripts which can be easily modified as needed )if something couldn't be done in ETL tool itself). The scripts can be easily scheduled using any external scheduler - and easily integrated with other systems.</p>
    <p>Ab Initio doesn't require a dedicated administrator.</p>
    <p>Ab Initio doesn't have built-in CDC capabilities (CDC = Change Data Capture).</p>
    <p>Ab Initio allows to (attach error / reject files) to each transformation and capture and analyze the message and data separately (as opposed to Informatica which has just one huge log). Ab Initio provides immediate metrics for each component.<br>
    </p>
    </td>
</tr>
<tr>
  <td bgcolor="#CCFFCC">override key</td>
  <td bgcolor="#FFFFCC">override key option is used when we need to join 2 fields which have different field names.</td>
</tr>
<tr>
  <td bgcolor="#CCFFCC">control file</td>
  <td bgcolor="#FFFFCC">control file should be in  the multifile directory (contains the addresses of the serial files)</td>
</tr>
<tr>
  <td bgcolor="#CCFFCC">max-core</td>
  <td bgcolor="#FFFFCC"> max-core parameter (for example, sort 100 MBytes) specifies the amount of memory used by a component (like Sort or Rollup) - per partition - before spilling to disk. Usually you don't need to change it - just use default value. Setting it too high may degrade the performance because of OS swapping and degrading of the performance of other components.</td>
</tr>
<tr>
  <td bgcolor="#CCFFCC">Input Parameters</td>
  <td bgcolor="#FFFFCC">graph &gt; select parameters tab &gt; click &quot;create&quot; - and create a parameter. Usage: $paramname. Edit &gt; parameters. These parameters will be substituted during run time. You may need to declare you parameter scope as formal.</td>
</tr>
<tr>
  <td bgcolor="#CCFFCC">Error Trapping</td>
  <td bgcolor="#FFFFCC">Each component has <span class="style1">reject</span>, <span class="style1">error</span>, and <span class="style1">log</span> ports. Reject captures rejected records, Error captures corresponding error, and log captures the execution statistics of the component. You can control reject status of each component by setting reject threshold to either Never Abort, Abort on first reject, or setting ramp/limit. You can also use force_error() function in transform function.<br></td>
</tr>
</table>
<p>3</p>
<table width="98%" border="1" cellspacing="0" cellpadding="5">
  <tr bgcolor="#FFCCCC">
    <td width="20%">Question</td>
    <td>Answer ==========================================================</td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">How to see resource usage</td>
    <td bgcolor="#FFFFCC">In GDE goto options View &gt; Tracking Details - will see each component's CPU and memory usage, etc.<br></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">assign keys component</td>
    <td bgcolor="#FFFFCC">Easy and saves development time. Need to understand how to feed parameters, and you can't control it easily.</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Join in DB vs join in Ab Initio</td>
    <td bgcolor="#FFFFCC"><ul>
      <li>Scenario 1 (preferred): we run query which joins 2 tables in DB and gives us the result in just 1 DB component.</li>
      <li>Scenario 2 (much slower): we use 2 database components, extract all data - and join them in Ab Initio.</li>
    </ul>      </td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Join with DB</td>
    <td bgcolor="#FFFFCC">not recommended if number of records is big. It is better to retrieve the data out - and then join in Ab Initio.</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Data Skew</td>
    <td bgcolor="#FFFFCC"><p>Parameter showing how data is unevenly distributed between partitions.</p>
    <p>skew = (partition size - avg.part.size)* 100 / (size of the largest partition)</p></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">dbc vs cfg</td>
    <td bgcolor="#FFFFCC"><p>.dbc - database configuration file (dbname, nodes, version user/pwd) - resides in the db directory</p>
    <p> .cfg - any tyoe of config file. for example, remote connection config (name of remote server, user/pwd to connect to db, location of OS on remote machine, connection method). .cfg file resides in the config dir.</p></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">compilation errors </td>
    <td bgcolor="#FFFFCC"><p>depth not equal data format error etc...</p>
    <p>depth error : we get this error.. when two components connected together but   does't match there layout </p></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">types of partitions</td>
    <td bgcolor="#FFFFCC">broadcast pbyexpression pbyroundrobin pbykey pwithloadbalance</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">unused port </td>
    <td bgcolor="#FFFFCC">when joining, used records go to the output port, unused records - to the unused port<br></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">tuning performance</td>
    <td bgcolor="#FFFFCC"><ul>
      <li>Go parallel using partitionning. Roundrobin partitionning gives good balance. </li>
      <li>Use Multi-file system (MFS).</li>
      <li>Use Ad Hoc MFS to read many serial files in parallel, and use concat component.</li>
      <li>Once data is partitionned - do not switch it to serial and back. Repartition instead.</li>
      <li>Do not acceess large filess via NFS - use FTP instead</li>
      <li>use lookup local rather than lookup (especially for big lookups).</li>
      <li>Use rollup and Filter as soon as possible to reduce number of records. Ideally do it in the source (database ?) before you get the data.</li>
      <li>Remove unnecessary <SPAN id="tfTextLink22775613085403273">components. For example, instead of using </SPAN> filter by exp, you can implement the same function in  reformat/Join/Rollup. Another example - when joining data from 2 files, use union function instead of adding an additional component for removing duplicates.</li>
      <li>use gather instead of concatenate.</li>
      <li>it is faster to do a sort after a partitino, than to do a sort before a partition.</li>
      <li>try to avoid using a join with the &quot;db&quot; component.</li>
      <li>when getting data from database - make sure your queries are fast (use indexes, etc.). If possible, do necessary selection / aggregation / sorting in the database before getting data into Ab Initio.</li>
      <li>tune Max_core for Optimal performance (for sort depends on the size of the input file).</li>
      <li>Note - If in-memory join cannot fit its non-driving inputs in the provided MAX-CORE,   then it will drop all the inputs to disk and in-memory does not make sence.</li>
      <li>Using phase breaks let you allocate more memory in individual components - thus improving performance.</li>
      <li>Use checkpoint after sort to land data on disk</li>
      <li>Use Join and rollup in-memory feature</li>
      <li>When joining very small dataset to a very large dataset it is more efficient to   broadcast the small dataset to MFS using broadcast component, or use the small   file as lookup. But for large dataset don't use broadcast as a partitioner.</li>
      <li>Use Ab Initio layout instead of database default to achieve parallel loads</li>
      <li>Change AB_REPORT parameter to increased monitoring duration </li>
      <li>Use catalogs for reusability</li>
      <li>Components like join/ rollup should have the option &quot;Input must be sorted&quot; <BR>
        if   they are placed after a sort component.</li>
      <li>minimize number of sort components. Minimize usage of sorted join component, and if possible replace them by in-memory   
        join/hash join. Use only required fields in the sort reformat join components. Use &quot;Sort within Groups&quot; instead of just Sort when data was already presorted.</li>
      <li>Use phasing/flow buffers in case of merge sorted joins </li>
      <li>Minimize the use of regular expression functions like re_index in the 
        transfer functions</li>
      <li>Avoid repartitioning of data unnecessarily. When splitting records into more than two flows, use  Reformat rather than   
        Broadcast component.</li>
      <li>For joining records from 2 flows use Concatenate component ONLY when there 
        is a need to follow some specific order in joining records. If no order is 
        required then it is preferable to use Gather component.</li>
      <li>Instead of putting many Reformat components consecutively, 
        use   output indexes parameter in the first Reformat component and mention the 
        condition there.<BR>
        <BR>
      </li>
    </ul></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">delta table</td>
    <td bgcolor="#FFFFCC"><ul>
      <li>Delta table maintain the sequencer of each data table. </li>
      <li>Master  (or base) table - a table on tp of which we create a view<BR>
        </li>
    </ul></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">scan vs rollup</td>
    <td bgcolor="#FFFFCC">rollup - performs aggregate calculations on groups, scan - calculates cumulative totals</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">packages</td>
    <td bgcolor="#FFFFCC">used in multistage components or transform components</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Reformat vs &quot;Redefine Format&quot;</td>
    <td bgcolor="#FFFFCC"><ul>
      <li>Reformat - deriving new data by adding/dropping fields</li>
      <li>Redefine format - <SPAN id="tfTextLink09514389914411975">rename</SPAN> fields</li>
    </ul></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Conditional DML</td>
    <td bgcolor="#FFFFCC">DML which is separated based on a condition</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">SORTWITHINGROUP</td>
    <td bgcolor="#FFFFCC"><ul>
      <li>The prerequisit for using sortwithingroup is that the data is already sorted by   the major key. sortwithingroup  <SPAN id="tfTextLink4156227926828259">outputs</SPAN> the data once it has finished reading the major key group. It is like an implicit phase.</li>
      </ul></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">passing a condition as a parameter</td>
    <td bgcolor="#FFFFCC"><p>Define a Formal Keyword Parameter of type string. For example, you call it  FilterCondition, and you want it to do filtering on COUNT &gt; 0 . Also in your graph in your &quot;Filter by expression&quot; Component enter following condition: $FilterCondition </p>
      <p>Now on your command line or in wrapper script give the following command<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YourGraphname.ksh -FilterCondition COUNT &gt; 0</p>      </td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Passing file name as a parameter</td>
    <td bgcolor="#FFFFCC"><pre><SPAN lang="" EN-GB></SPAN><SPAN lang="" EN-GB>#!/bin/ksh</SPAN></pre>
      <pre><SPAN lang="" EN-GB>#Running the set up script on   enviornment
typeset PROJ_DIR $(cd $(dirname $0)/..; pwd) 
.   $PROJ_DIR/ab_project_setup.ksh $PROJ_DIR
#Exporting the script parameter1 to   INPUT_FILE_NAME
if [ $# -ne 2 ];
then
  INPUT_FILE_PARAMETER_1   $1
  INPUT_FILE_PARAMETER_2 $2
  # This grpah is using the input   file
  cd $AI_RUN
  ./my_graph1.ksh $INPUT_FILE_PARAMETER_1
  # This graph also is using the input   file.
  ./my_graph2.ksh $INPUT_FILE_PARAMETER_2
  exit 0;
else
  echo Insufficient   parameters 
  exit 1;
fi
-------------------------------------
#!/bin/ksh

#Running the set up script on enviornment
typeset PROJ_DIR $(cd $(dirname $0)/..; pwd) 
. $PROJ_DIR/ab_project_setup.ksh $PROJ_DIR

#Exporting the script parameter1 to INPUT_FILE_NAME
export INPUT_FILE_NAME $1

# This grpah is using the input file
cd $AI_RUN
./my_graph1.ksh

# This graph also is using the input file.
./my_graph2.ksh

exit 0;</SPAN></pre></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">How to remove header and trailer lines?</td>
    <td bgcolor="#FFFFCC"><p>use conditional dml where you can separate detail from header and trailer. For validations use reformat with count :3 (out0:header out1:detail   out2:trailer.)</p>    </td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">How to create a multi file system on Windows</td>
    <td bgcolor="#FFFFCC"><ul>
      <li>first method: in GDE go to RUN &gt; Execute Command - and run m_mkfs c:control c:dp1 c:dp2 c:dp3 c:dp4</li>
      <li>second method: double-click on the file component, and in ports tab double-click on partitions - there you can enter the number of partitions.</li>
    </ul>      </td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Vector</td>
    <td bgcolor="#FFFFCC">A vector is simply an array. It is an ordered set of elements of the same type (type can be any type, including a vector or a record).</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Dependency Analysis</td>
    <td bgcolor="#FFFFCC">Dependency analysis will answer the questions regarding <span class="style1">datalinage</span>, that is where does the data come from what applications prodeuce and depend on this data etc..</td>
  </tr>
</table>
<p>4</p>
<table width="98%" border="1" cellspacing="0" cellpadding="5">
  <tr bgcolor="#FFCCCC">
    <td width="20%">Question</td>
    <td>Answer ==========================================================</td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">Surrogate key </td>
    <td bgcolor="#FFFFCC"><p>There are many ways to create a surrogate key. For example, you can use <span class="style1">next_in_sequence()</span> function in your transform. Or you can use &quot;<span class="style1">Assign key values</span>&quot; component. Or you can write a stored procedure - and call it.</p>
      <p>Note: if you use partitions, then do something like this: </p>
      <p>(next_in_sequence()-1)*no_of_partition()+this_partition()<br>
        </p></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">.abinitiorc</td>
    <td bgcolor="#FFFFCC"><p> This is a  config file for ab initio - in user's home directory and in $AB_HOME/Config. It sets abinitio home path,  configuration variables (AB_WORK_DIR, AB_DATA_DIR, etc.), login info (id, encrypted password), login methods for hosts for execution (like EME host, etc.), etc.</p>    </td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">.profile</td>
    <td bgcolor="#FFFFCC"><p>your ksh init file (
      environment, aliases, path variables, history file settings, command prompt settings, etc.)</p>    </td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">data mapping, data modelling</td>
    <td bgcolor="#FFFFCC">&nbsp;</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Hwo to execute the graph</td>
    <td bgcolor="#FFFFCC">From GDE - whole graph or by phases. From checkpoint. Also using ksh  scripts</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Write Multiplefiles</td>
    <td bgcolor="#FFFFCC">A component which allows to write simultaneously into multiple local files</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Testing</td>
    <td bgcolor="#FFFFCC">Run the graph - see the results. Use components from Validate category.</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Sandbox vs EME</td>
    <td bgcolor="#FFFFCC"><span class="style1">Sandbox</span> is your private  area where you  develop and test. Only one project and one version can be in the sandbox at any time. The <span class="style1">EME Datastore</span> contains all versions of the code that have been checked into it (source control).</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Layout</td>
    <td bgcolor="#FFFFCC">Where the data-files are and where the components are running. For example, for data - serial or partitioned (multi-file). The layout is defined by the location of the file (or a control file for the multifile). In the graph the layout can  propagate automatically (for multifile you have to provide details).</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Latest versions</td>
    <td bgcolor="#FFFFCC">April 2009: GDE ver.1.15.6,  Co-operative   system ver 2.14.</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Graph parameters</td>
    <td bgcolor="#FFFFCC">menu edit &gt; parameters - allows you to specify private parameters for the graph. They can be of 2 types - local and formal.</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Plan&gt;It</td>
    <td bgcolor="#FFFFCC">You can define pre- and post-processes,  triggers. Also you can specify methods to run on success or on failure of the graphs.</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">Frequently used components</td>
    <td bgcolor="#FFFFCC"><ul>
      <li>input file / output file</li>
      <li>input table / output table</li>
      <li>lookup  / lookup_local</li>
      <li>reformat</li>
      <li> gather / concatenate</li>
      <li> join</li>
      <li> runsql</li>
      <li> join with db</li>
      <li> compression components</li>
      <li>filter by expression</li>
      <li> sort (single or multiple keys)</li>
      <li>rollup</li>
      <li> trash</li>
      <li> partition by expression / partition by key</li>
    </ul>      </td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">running on hosts</td>
    <td bgcolor="#FFFFCC">co&gt;operating system is layered on top of native OS (unix). When running from GDE, GDE generates a script (according to &quot;run&quot; setings). Co&gt;op system will execute the scripts on different machines (using specified host settings and connection methods, like rexec <SPAN id="tfTextLink8412162802654682">telnet</SPAN> rsh rlogin) - and then return error or success codes back.</td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">conventional loading vs direct loading</td>
    <td bgcolor="#FFFFCC"><p>This is basically an Oracle question - regarding SQLLDR (SQL Loader) utility. Conventional load - using insert statements. All triggers will fire, all contraints will be checked, all indexes will be updated.</p>
    <p>Direct load - data is written directly block by block. Can load into specific partition. Some constraints are checked, indexes may be disabled - need to specify native options to skip index maintenance. </p></td>
  </tr>
  <tr>
    <td bgcolor="#CCFFCC">semi-join</td>
    <td bgcolor="#FFFFCC"><p>abinitio online help gives 3 examples of joins: inner join, outer join, and semi join.</p>
    <ul>
        <li>for inner join 'record_requiredN' parameter is true for all &quot;in&quot; ports.</li>
        <li>for outer join it is false for all the &quot;in&quot; ports.</li>
        <li>for semi join it is true for both port (like InnerJoin), but the dedup option is set  only on one side</li>
    </ul></td>
  </tr>
</table>
<p>http://www.geekinterview.com/Interview-Questions/Data-Warehouse/Abinitio/page10</p>
<p>10,11,12,13,14,15,16,17,18,19,20</p>
<p class="sectionheader">Some alternative vendors:</p>
<ul>
  <li><a href="etl.html">etl.html</a> , <a href="http://en.wikipedia.org/wiki/Etl#Tools">http://en.wikipedia.org/wiki/Etl#Tools</a></li>
  <li><a href="http://en.wikipedia.org/wiki/IBM_InfoSphere_DataStage">http://en.wikipedia.org/wiki/IBM_InfoSphere_DataStage</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Expressor">http://en.wikipedia.org/wiki/Expressor</a>, <a href="http://www.expressor-software.com">http://www.expressor-software.com</a></li>
  <li> <a href="http://en.wikipedia.org/wiki/Informatica">http://en.wikipedia.org/wiki/Informatica</a></li>
</ul>
<p class="sectionheader">Disclaimer</p>
<p> This page contains only data publicly available on the web. It doesn't contain any secret or proprietary information.</p>
<p></p>
<table width="98%" border="1" cellspacing="0" cellpadding="5">
  <tr bgcolor="#FFCCCC">
    <td width="20%">Question</td>
    <td>Answer ==========================================================</td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">xxxx</td>
    <td bgcolor="#FFFFCC">xxxx<br></td>
  </tr>
</table>
<p>&nbsp;</p>
<table width="98%" border="1" cellspacing="0" cellpadding="5">
  <tr bgcolor="#FFCCCC">
    <td width="20%">Question</td>
    <td>Answer ==========================================================</td>
  </tr>
  <tr>
    <td width="20%" bgcolor="#CCFFCC">xxxx</td>
    <td bgcolor="#FFFFCC">xxxx<br></td>
  </tr>
</table>
<p>&nbsp;</p>
<p></p>
<p></p>
</body>
</html>
