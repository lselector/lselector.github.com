<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.76 [en] (Windows NT 5.0; U) [Netscape]">
</head>
<body>
As I look around here, I see a lot of young faces.&nbsp; Almost too young.
I like youth.&nbsp; I always planned to stay young all my life.&nbsp; I've
always been blessed with a face that's younger than my age, so I've tried
to always adopt a young attitude to go with my face.
<p>You can fool some of the people all of the time, but you can't fool
Mom.&nbsp; I think she knows that I'm just a late bloomer (speaking of
procrastination).&nbsp; I'm late for a lot of things, not just blooming.
For instance, I only started writing this talk yesterday.&nbsp; Another
one of these Just In Time talks.&nbsp; I'll probably finish it sometime
tomorrow.&nbsp; Lateness is one of my specialties.&nbsp; Someday I'll be
dead, and when you refer to me as "the Late Larry Wall", people will think
you were joking.
<p>Speaking of my long-lost youth, I remember sometime way back during
the Kennedy administraion, my grade school teacher asked us all to calculate
how old we'd be in the year 2000.&nbsp; I got the unfathomable answer of
46.&nbsp; I could imagine being 10, maybe. But 46 is a lot closer to infinity!
Anyway, I couldn't imagine being 46.&nbsp; Now I can.&nbsp; As of last
month, I'm officially in my late 40s.&nbsp; Whoopee!&nbsp; Does this mean
I can schedule my mid-life crisis soon?
<p>Besides my birthday, I recently noticed several things that tell me
I'm not so young any more.&nbsp; The first thing I noticed is that I took
my first child, Heidi, off to college.&nbsp; Believe me, even if you don't
notice your kids while you still have them, you'll definitely notice them
when they go away.
<p>The second thing I noticed is ... I forget what.
<p>The third thing I noticed is that I want to start reminiscing about
my youth.&nbsp; Old people really only have three things to say: how good
it was back then, how bad it is now, and (if you're lucky) how much worse
it will be in the future. So, I'd like to talk about how good it was back
then, how bad it is now, and how much worse it will be in the future. Actually,
I just said that to be funny.&nbsp; <font color="#3333FF">I really do think
things are getting better</font>, and the getting betterness is what I
would like to talk about.
<p>The name of this talk (for the moment, I might change it) is:
<center>
<p><b><font color="#CC0000">Camel Lot #6, The Once and Future Perl.</font></b></center>

<p>I'm going to do a little bit like Ken did last night, and take you through
how bad it used to be and how good it's getting, and on to the future.&nbsp;
A chronological outline is a great way to go.&nbsp; Some of you may recognise
some of these slides.&nbsp; In fact, these are probably about 10 years
old, some of them.&nbsp; I put them in more for historical value. If you
look closely, you can see gritchineses--that's an overhead transparency
that I scanned.&nbsp; So this is the real original.
<p><font color="#CC0000">[How It Was Back Then (Sort Of)]</font>
<p>Way back in the dawn of time, this is what Unix looked like.&nbsp; Either
you programmed in C, or you programmed in shell.&nbsp; Of course, those
were two different realms, and it was sort of one or the other.&nbsp; We
had this dichotomy of our thinking, that you had to do one or the other.
<p><font color="#CC0000">[How It Really Was Back Then]</font>
<p>How it really was back then--one day it opened up to me, these were
not opposites, but think of an oyster shell opening up here.&nbsp; Instead
of opposites, they were two different dimensions in space that you could
graph things like this.&nbsp; You could consider sed and awk to be sort
of warts on the shell.
<p>For those of you at the back who can't read this, the left hand axis
(what C is good at) is called "manipulexity" and the horizontal attitude
is called "whipuptitude".
<p>With that realization I realized that there was a big gray area out
there.&nbsp; In biological terms, that's an ecological niche.&nbsp; So
I decided to fill it.
<p><font color="#CC0000">[The Hatching of an Idea]</font>
<p>Perl got hatched, and that's kinda why it's egg-shaped there.&nbsp;
From the beginning it was designed to grow into that space.&nbsp; Perl
was always designed to be an evolving language.
<p>The reason I'm telling you some of this stuff is that, as some of you
know, we've announced Perl 6, and I'm going to be talking about that later.&nbsp;
And<b><font color="#CC0000"></font></b>
<center>
<p><b><font color="#CC0000">one of the very very high level goals of Perl
6 is to keep Perl capable of evolving.</font></b></center>

<p>Perl 5 was running into some limits and we're going to figure out how
to get around those limits.
<p>So it appears that there are these two axes of C and shell.&nbsp; And
there could be other dimensions: the Python dimension, the Java dimenson.
But
<center>
<p><b><font color="#CC0000">you don't want to think of either/or.</font></b></center>

<p>It's really easy for people (especially computer scientists) to get
locked into this either-or thing.&nbsp; Either I use the GPL or I don't.&nbsp;
Well, why not use the GPL *and* some other license?&nbsp; Is that right,
Ken?&nbsp; [Ken Coar had been lamenting the difficulties of the GPL the
night before, but didn't mention dual licensing.]&nbsp; It wasn't long
after that that I invented dual licensing, and I think that actually works
pretty well.
<p>So there are lots of ways in which we try to avoid falling into the
either-or trap.&nbsp; Perl got its philosophical inputs from four different
areas, not just from computer science.&nbsp; (Obviously).
<p><font color="#CC0000">[The Inputs]</font>
<p>>From this diagram, you can see that computer scientists tend to not
like things to be Art.&nbsp; They prefer things to be scientific.&nbsp;
So Computer Science is sort of the opposite of Art, maybe, but I don't
know that Linguistics is the opposite of Common Sense.&nbsp; Maybe it is--I've
been trying to learn Japanese lately ....&nbsp; People say that Perl is
hard to learn.&nbsp; Nu-uh!&nbsp; *Japanese* is hard to learn!
<p><font color="#CC0000">[What to Take, What to Leave Behind]</font>
<p>More specifically, here are some points that Perl took from those four
languages I listed earlier.&nbsp; The bold things are things that I borrowed,
and the non-bold things are things that I specifically left behind.&nbsp;
People often think that Perl is hodge-podge, everything including the kitchen
sink, but I actually left out a few of the kitchen sinks along the way.&nbsp;
Still, a few have snuck in and that's what I'll talk about later.
<p>The question is, when you combine things like this, is it good or is
it bad?
<p><font color="#CC0000">[Question: bastardization or hybrid vigor?]</font>
<p>Well, that's a personal judgement.&nbsp;&nbsp; I have my opinion on
it.
<p><font color="#CC0000">[My Irrationalities]</font>
<p>I have a lot of opinions, actually, and some of them you'll notice in
the design of Perl.&nbsp; I don't like dangling syntax, and I think that
ordinary people like me hate abstractions.&nbsp; Hmm, that sorta assumes
that I'm ordinary.&nbsp; I do think of myself as ordinary. Ordinary-weird,
but ordinary.
<p><font color="#3333FF">And I believe contradictory things.&nbsp; I believe
that C is wonderful and I believe C is awful.&nbsp; And that awk is neither.</font>
<p>I think that language is an amoral medium, by which I mean that language
itself is like an artistic medium, like paint.&nbsp; You don't have pretty
paints and ugly paints, it's after you arrange them on a canvas that they
get pretty or ugly.&nbsp; Similarly, language is something you can use.&nbsp;
You can write beautiful poems, or ugly flames.&nbsp; Or beautiful flames...
<p><font color="#3333FF">I think ugly can be beautiful, and that beautiful
can get ugly real quick.&nbsp; I think in particular of Lisp, which is
the most beautiful language in the world, and every program in Lisp is
real ugly.</font>
<p>I think visual metaphor is for more than just poetry, so I think things
that are different oughta look different.
<p>The next one applies to language designers:
<center>
<p><font color="#CC0000">you have to simultaneously not care what other
people think, and care what other people think.</font></center>

<p>And I think that God has free will, which is why he designed us to be
creative.&nbsp; Which is why programmers prefer to have more than one way
to do it--they have choices, and that's what makes programming fun.
<p><font color="#CC0000">[Common Fallacies of Language Design]</font>
<p>Now lots of people design computer languages, and fall into all sorts
of traps:
<p><font color="#3333FF">"Now, we have to start over from scratch"</font>.&nbsp;
That's almost any academic language, which throws out all the existing
art and says "we're going to make people think entirely different from
how they did before".
<p><font color="#3333FF">"If we put in English phrases, that makes it readable"</font>.&nbsp;
That's COBOL.
<p><font color="#3333FF">"Simple languages produce simple solutions"</font>.&nbsp;
There are lots of simple languages, but simple languages produce complicated
solutions because you have to be verbose.
<p><font color="#3333FF">"If I wanted it fast, I'd write it in C"</font>.&nbsp;
That was the original reasoning behind making awk run so slow.
<p><font color="#3333FF">"I thought of a way to do it so it must be right"</font>.&nbsp;
That's a very common trap: people just implement the first thing they think
of.
<p><font color="#3333FF">"This is a very high level language--who cares
about bits?"</font>&nbsp; Again, like awk.
<p><font color="#3333FF">"You can do anything you want with NAND gates"</font>.&nbsp;
That's Turing machines, I guess, or something like that.
<p><font color="#3333FF">"Users care about elegance."</font>&nbsp; No,
they care about getting their job done.&nbsp; For some reason lots of languages
that come out of Europe have this thing about elegance that I don't quite
get.&nbsp; Obviously.
<p><font color="#3333FF">"The specification is good enough"</font>.&nbsp;
That's Ada.
<p><font color="#3333FF">"Abstraction = usability"</font>.&nbsp; That's
Lisp or Scheme, or maybe ML.
<p><font color="#3333FF">"The core should be as small as possible."</font>&nbsp;
That's Forth.
<p><font color="#3333FF">"Let's make this easy for the computer."</font>&nbsp;
That's assembly language.
<p><font color="#3333FF">"Most programs are designed top down."</font>&nbsp;
That's Pascal.
<p><font color="#3333FF">"Text processing doesn't matter."</font>&nbsp;
Fortran.
<p><font color="#3333FF">"People should never have been given free will."</font>&nbsp;
Lots of languages.
<br>&nbsp;
<p><font color="#CC0000">[Larry's Conjecture]</font>
<p>I think that what actually makes a language useful is not the theory
involved in it.&nbsp; Theory is good, but if you drive a particular theory
into the ground, that just drives people away.
<p>So a language's practicality is inversely proportional to the number
of theoretical axes the language has to grind.&nbsp; I don't mind theory,
I just don't like theoretical axes.
<p><font color="#CC0000">[Waterfall or Whirlpool?]</font>
<p>Now there's an interesting chart that I go back to look at again and
again, to remind me that programming is not a sequential activity. We already
saw the fallacy of either/or thinking.&nbsp; Another fallacy we often fall
into is sequential thinking.
<p>Some of you may have heard of the waterfall chart, which talks about
doing specification, then you go to the design, then coding, then testing.&nbsp;
But really it's more of a chaotic strange attractor, where all of these
things are going on simultaneously.&nbsp; You know, "Ready! Fire! Aim!"
is how we program.&nbsp; There are some methodologies that advocate testing
before doing coding and then doing the design, and I think that's one of
the eXtreme Programming tenets.
<p>Right now as I'm giving this talk, Camelot #6, it's about perl 6, I
think that Perls 1 through 5 were prototypes for Perl 6.&nbsp; And you
plan to throw away the prototypes ...
<p><font color="#CC0000">[The UNIX Family Tree]</font>
<p>Now Unix has an interesting history (audience laughter).&nbsp; I think
this down here is the little dance being done by BSD and Linux.
<p><font color="#CC0000">[The C Family Tree]</font>
<p>The C family tree kinda looks like this (more laughter).&nbsp; We had
K&amp;R C to begin with, then we had gazillion different types of C, then
we had ANSI C, and then ... something happened.&nbsp; (laughter)
<p><font color="#CC0000">[The C Family Tree, Cont.]</font>
<p>And then something else happened.&nbsp; (more laughter)
<p><font color="#CC0000">[How Microsoft Sees It]</font>
<p>And then something else happened, and this is the Microsoft view of
reality (yet more laughter).
<p><font color="#CC0000">[The Perl Family Tree]</font>
<p>Here's the Perl family tree.&nbsp; Actually, this is slightly disingenuous,
because there was a little branch off to the side when ActiveState first
ported Perl to the Windows platform, but we made a big effort and pulled
it back together.&nbsp; So the line got a little wider there and got narrower
again.&nbsp; The nice thing about open source is that you can pull things
back together again if you really need to.
<p>The slide has said "under construction" down there from the beginning,
and it still says that.
<p><font color="#CC0000">[The Other Perl Family Tree]</font>
<p>Here's the other way of looking at the Perl family tree.&nbsp; Needless
to say this is notional.
<p><font color="#CC0000">[Natural Language Concepts]</font>
<p>Now Perl's design, from the beginning, since my background is both in
linguistics and computer science, has a lot of linguistics notions.&nbsp;
Not on the level of COBOL, where it just looks like English, but on a deeper
level.
<p>A natural language you learn it once, and you use it many times.&nbsp;
So you should optimize for expressiveness, not for learnability.&nbsp;
I think somebody had told that to the Japanese before they designed their
language, and I wish their language was a little easier to learn.
<p>Another thing about language is that you learn as you go, and <u><font color="#3333FF">many
acceptable levels of competence are ... acceptable</font></u>.&nbsp; That
means we don't expect a 5 year old to speak with the same level of competence
as a 50 year old.&nbsp; Or a 46-year old.&nbsp; And it's perfectly okay
for a kid to use kid-talk and a baby to use baby-talk.&nbsp; <font color="#CC0000">Contrast
that with your typical C++ shop where if you don't know the whole language
and program in a subset of C++, you get laughed out of the office</font>.
<p>To me it should be acceptable to program in Perl subsets.&nbsp; If you
want to program in the subset that looks like awk, sed, or C, that's fine.
Or the subset that looks like Python ... (slow laughter)&nbsp; Some of
you are awake.
<p>There are more points here that I'm not going to go through.&nbsp; The
explanations are on my website if you're interested.&nbsp; There are many
more things that are based on how we use natural language, and I don't
want to lose that as we go forward and evolve Perl.
<p><font color="#CC0000">[Perl 5: The Big Nouns]</font>
<p>So for more recent history, meaning 5 years ago plus or minus, when
Perl 5 first came out this was what we announced as the goals of Perl 5.&nbsp;
Perl 5 did improve in all of these areas.&nbsp; When I look back at it
now, in all of these areas it can continue to improve.&nbsp; So most of
the rest of this talk is going to be about that.
<p><font color="#CC0000">[Constraints on Perl 5]</font>
<p>Now Perl 5 had some constraints on its design.&nbsp; First of all was
the need for backward compatibility.&nbsp; We have deprecated a few things
along the way, but most of them were what I call 'eternally deprecated':
"Don't do that, but it still works".&nbsp; So most of your Perl 1 scripts
(I'm sure you've all written Perl 1 scripts right?&nbsp; Some of you weren't
born then!) still work in Perl 5 for the most part.&nbsp; You might get
some warnings, but we had to keep the backward compatibility at that point.
<p>Of course another constraint on the design of Perl 5 was my own
<br>idiocy.&nbsp; That was the last time I designed the language by myself,
so
<br>I was limited by my own imagination.&nbsp; And the cultural model of
Perl 5
<br>worked for Perl 5, but it had bottle necks in it, in terms of how we
<br>developed it.&nbsp; Having one person in charge of all the integration
<br>tends to be a bottleneck.&nbsp; Yes, you know that.
<p>Of course, there was ignorance of the future.&nbsp; And there were some
<br>places where I was ignorant of the present and the past, but we'll
let
<br>that go.
<p>And a lack of round tuits.
<p>And another way in which Perl 5 was constrained was that in dealing
<br>with all the other things there, the core was quite complex.&nbsp;
You like
<br>it when Perl rips through a file really quickly, doing pattern
<br>matching or whatever it's doing, but a lot of that is because of the
<br>internals doing optimizations and the like.&nbsp; So it's a little
hard to
<br>get in there and actually change it, particularly if you're starting
<br>out.&nbsp; There aren't that many people that can do it, and that limits
<br>how much Perl 5 can evolve.
<p>And then of course there's the issue of complacency.&nbsp; You can easily
<br>sit there and say "well, it's good enough".&nbsp; That was sort of
starting
<br>to happen.
<p>[The Summer of our Discontent]
<p>Between version 5.005 and 5.6, it took about two years.
<br>There were many reasons for that, some of them I mentioned on the last
<br>slide.&nbsp; A personal reason is that I was busy writing the new Camel
<br>book, Camel 3 as we call it.&nbsp; I was busy with the Perl Whirl cruise
<br>(you know, there's a Linux Lunacy cruise coming up.&nbsp; I highly
<br>recommend it.&nbsp; It's cheaper than you think, because the cruise
lines
<br>are overbuilt so they're trying to get people to go on all these
<br>cruises.&nbsp; I was expecting the Perl cruise to be all these old
fogeys
<br>pretending to be Perl programmers, but it was really much of the same
<br>demographics as you.&nbsp; But I spent a good part of it proofing the
Camel
<br>book in my cabin.&nbsp; You look up every five minutes and "there's
a
<br>beautiful view, oh nice", then go back to proofing).
<p>After that I was busy getting ready for Yet Another Perl Conference
<br>19100 (that's what they called it), and after that getting ready for
<br>the Perl Conference 4.0.
<p>As much as a year before the Perl conference, we'd said to ourselves
<br>"you know, we should have ourselves a constitutional convention and
<br>figure out how to reorganize the community to be more effective".&nbsp;
And
<br>yeah, that's a great idea, but finally this last summer Chip
<br>Salzenberg said, "Let's have one of those meetings."
<p>We started having one, and an interesting thing happened.&nbsp; We spent
<br>the first hour gabbing about all sorts of political and organizational
<br>issues of a fairly boring and mundane nature.&nbsp; Partway through,
Jon
<br>Orwant comes in, and stands there for a few minutes listening, and
<br>then he very calmly walks over to the coffee service table in the
<br>corner, and there were about 20 of us in the room, and he picks up
a
<br>coffee mug and throws it against the other wall and he keeps throwing
<br>coffee mugs against the other wall, and he says "we are fucked unless
<br>we can come up with something that will excite the community, because
<br>everyone's getting bored and going off and doing other things".
<p>And he was right.&nbsp; His motivation was, perhaps, to make bigger
Perl
<br>conferences, or he likes Perl doing well, or something like that.&nbsp;
But
<br>in actual fact he was right, so that sort of galvanized the meeting.
<br>He said "I don't care what you do, but you gotta do something big."
<br>And then he went away.
<p>Don't misunderstand me.&nbsp; This was the most perfectly planned tantrum
<br>you have ever seen.&nbsp; If any of you know Jon, he likes control.&nbsp;
This
<br>was a perfectly controlled tantrum.&nbsp; It was amazing to see.&nbsp;
I was
<br>thinking, "Should I get up and throw mugs too?"
<p>Anyway, so we started talking after that and the idea popped up that
<br>maybe we oughta rewrite Perl.&nbsp; The idea that occurred to me then
was
<br>that we had some new technology: Perl has a decompiler now.&nbsp; You
can
<br>take a Perl 5 script and compile it down to the bytecode, and take
<br>that and compile it back to Perl 5 code.&nbsp; And if you can do that,
why
<br>not compile it back to Perl 6 code?
<p>So with that realization, we are now free to actually do a major
<br>redesign.&nbsp; What can we do that we would have done differently
if we
<br>had known better, 14 years ago?
<p>So later that day we also had an open meeting of the perl porters,
<br>with about 50 people there, and we started handing out tasks about
how
<br>we would do the redesign.&nbsp; And the next day in my keynote I announced
<br>that we were rewriting Perl.&nbsp; I only got about three hours of
sleep that
<br>night because I was rewriting my speech.&nbsp; That would have been
okay
<br>except that I'd only had three hours the night before.&nbsp; So if
you
<br>listen to that audio on the net, you'll hear that I sound very spaced
<br>out.&nbsp; Er, more than usual.
<p>So anyway, Perl 6.&nbsp; As I was flying here on Delta Airlines, the
<br>monitor was showing all sorts of happy sayings.
<p>["If you can dream it, you can do it"--Walt Disney]
<p>"If you can dream it, you can do it"--Walt Disney.&nbsp; Now this is
<br>actually false (massive laughter).&nbsp; I think Walt was confused
between
<br>necessary and sufficient conditions.&nbsp; If you *don't* dream it,
you can't
<br>do it; that is certainly accurate.
<p>[Reinventing Everything]
<p>So we've been dreaming.&nbsp; Everything's fair game. We've been thinking
<br>how to reinvent the lexer, the parser, the interpreter, the code
<br>generators, the internal APIs, the external APIs, the language itself,
<br>and the culture surrounding it.&nbsp; And interestingly, the first
thing we
<br>started reinventing was the culture.
<p>[New Working Group Model]
<p>Here are some mailing lists that have sprung up since August 1, and
a
<br>rough idea of the number of messages that have been posted to each
of
<br>those.&nbsp; These correspond to various working groups.&nbsp; We have
a working
<br>group model where there's an official person in charge of each working
<br>group, and there's a charter, and there's a sunset law where at a
<br>certain date we will shut ourselves down unless we can justify
<br>continuing our existence.&nbsp; So we're doing something very different
<br>from the perl5-porters mailing list that has gone on forever, and
<br>isn't much about porting any more.
<p>So there's much more sense of responsibility, and people are holding
<br>themselves accountable.&nbsp; And the amount of raw flamage has been
less
<br>than in the old days.&nbsp; So, so far so good on the culture, and
we'll
<br>continue evolving the culture.
<p>As you can see, some of these working groups look very general.
<br>perl6-language obviously has a lot of activity and will probably go
<br>on for a long time.&nbsp; Some of these were working groups set up
to
<br>discuss one little issue, one RFC, and sometimes the timing was a
<br>little off.&nbsp; If you look at the perl6-language-unlink one, they
<br>created the mailing list just as the discussion was dying, so it never
<br>got anything on it.&nbsp; But this tells you of some of the ways we're
<br>breaking down the culture here.
<p>In particular, there's an official way of announcing RFCs.&nbsp; We're
<br>splitting the language issues from the internals issues.&nbsp; Build
issues
<br>are being covered.&nbsp; QA.&nbsp; Notice that that's perl-qa -- we're
hoping
<br>that we can back-apply some of the QA things we develop in Perl 6 back
<br>to Perl 5.
<p>Now one thing I want to make clear about this Perl 6 activity is that
<br>we're not abandoning Perl 5 any time soon.&nbsp; We don't know how
long this
<br>Perl 6 will take.&nbsp; There are still some people using Perl 4 out
there.
<p>[The Constraints on Perl 6]
<p>Now Perl 6 has a different set of constraints.&nbsp; Hopefully these
are
<br>more liberal constraints than Perl 5 had.&nbsp; It's still the case
that
<br>Larry needs to understand Perl 6.&nbsp; For some strange reason, even
though
<br>they split off into all these working groups, and they have a language
<br>working group, they appointed me Chief Language Designer.&nbsp; So
I said
<br>"okay".
<p>So I need to make sure that I grok everything that's out there.&nbsp;
That
<br>doesn't mean that I had to come up with it in the first place.&nbsp;
That
<br>doesn't mean that I have to understand how to do it, only how it's
<br>going to interact with other things.
<p>Other constraints that we were putting on the design: you can propose
<br>a new feature, but if it's not something that people really need,
<br>we're not going to put it in.&nbsp; The underlying philosophy of Perl
is
<br>to serve, and if it doesn't serve our needs then what good is it?
<p>Can we implement it efficiently and robustly?
<p>And a biggie here--does it preclude translation from Perl 5?&nbsp; We
need
<br>to be able to have a migration path from Perl 5 to Perl 6, so if you
<br>distort the semantics too violently then it becomes too difficult to
<br>translate.&nbsp; So Perl 6 will bear a close resemblance in some ways
to
<br>Perl 5.
<p>Does the utility of the change grow faster than the complexity?&nbsp;
And
<br>does the size of the executable grow slower than Moore's law?&nbsp;
These
<br>things always grow over time, but is the computer getting faster faster?
<p>And we have to take the time to maintain Perl 5, and we also have to
<br>make sure that we take the time to design Perl 6 right.&nbsp; There's
never
<br>time to do it right, but there's always time to do it over--but we
<br>want to do it over first.&nbsp; Or something like that...
<p>[The RFC process]
<p>The RFC process.&nbsp; We call them RFCs, and they really are Requests
For
<br>Comments, they're not standards!&nbsp; There are currently 361 RFCs,
<br>they're written in Plain Old Document format, and they must be
<br>well-formed to be acceptable to be announced and posted on
<br>dev.perl.org.&nbsp; They're subject to revision, retraction, rethink.
<p>The first one came out right after the Perl conference, and we had it
<br>open for brainstorming essentially until the end of last month.&nbsp;
And
<br>that's when I got a snapshot of it.&nbsp; The theory was that I would
read
<br>all these RFCs in two weeks and come up with a language design by today.
<br>Riiiight.&nbsp; I've read the abstracts of all of them but the last
50.&nbsp; If
<br>I run out of things to say here, I'll read the last 50 and take a
<br>master class approach here.
<p>[Handwaving Requirements]
<p>These are things that will be in Perl 6, for some definition or other,
<br>but they are somewhat nebulous.&nbsp; Perl needs to support higher
level
<br>programming, and I'll go into some of these as we go along, and it
<br>must support lower level programming.&nbsp; It'd be nice if it supported
<br>more paradigms, yes the p-word.&nbsp; And we really want to avoid the
<br>equivalent of DLL hell.&nbsp; It's getting harder and harder with all
these
<br>modules out on CPAN, with different versions of them, to keep them
all
<br>straight.&nbsp; There are ways of handling these sorts of things.
<p>"Perl must support absolute flexibility".&nbsp; There's actually an
RFC
<br>that says "Perl 6 will be the last version of Perl".&nbsp; By which
they
<br>mean, "we'll do it good enough that there'll be no need for a Perl
7."
<br>In fact, they say that the version number will asymptotically approach
<br>pi*2.&nbsp; That's what the RFC says, I haven't said whether it's right
or
<br>not.
<p>It needs to have a mean and lean core, and we'll talk about that.
<br>Perl must not surprise people unnecessarily, and there are still ways
<br>in which Perl surprises people and we can reduce some of that.&nbsp;
It
<br>needs to be as simple as possible, but no simpler.&nbsp; It needs to
map
<br>well onto your problem.&nbsp; The better your solution space maps onto
your
<br>problem space, the more compact your solution will be.&nbsp; And Perl
must
<br>remain Perl.&nbsp; There's an RFC that says that too.
<p>[Simplifications]
<p>There's a lot of things we can simplify, going from Perl 5 into Perl
6.
<br>If the core is going to be lean and mean, that implies that a lot of
<br>stuff are going to move out of the core.&nbsp; Non-critical built-ins,
<br>sockets, operating system stuff, and so on, will be moved out to
<br>modules.&nbsp; Now they might be autoloaded, so they look like they're
in
<br>the core, but there's no reason they have to be there to begin with.
<br>So we can discount those in the internals design, provided of course
<br>that calling out to those modules is efficient.&nbsp; So that's another
<br>goal.
<p>All variables will be usable as objects.&nbsp; There are ways in which
you
<br>would like to be able to treat arrays and hashes and scalars as
<br>objects, so for instance (and this comes back to the category of not
<br>surprising people) people expect length() to work on arrays.&nbsp;
That's
<br>because they're thinking of the array as an object, not as a list in
<br>scalar context.&nbsp; So probably length() is going to become a method
on
<br>the array object.&nbsp; So the translator for Perl 5 will actually
have to
<br>translate the mistake of saying length(@array)!
<p>In any event, all the variables are actually objects internally.&nbsp;
And
<br>rather than having this funny conditional code like Perl 5 does,
<br>everything will be run off vtables as C++ does.&nbsp; That does not
<br>necessarily imply thtat we are writing it in C++, probably not, but
<br>that's all implementation.&nbsp; That will be very efficient and it
will
<br>allow alternate implemenations to be swapped in and out very quickly,
<br>loaded as modules.
<p>Now many of the strange global variables that you know and love dearly
<br>will be lexically scoped.&nbsp; That will simplify things like
<br>multithreading.&nbsp; Filehandles become objects using object-oriented
<br>notation, meaning we've decided that they'll be regular scalar
<br>variables instead of bare filehandles as they are now.&nbsp; This
<br>simplifies a whole bunch of things, one of those things is the parsing
<br>rules for indirect objects.&nbsp; We can probably simplify the parsing
<br>rules in other places as well, disambiguation rules, and might even
go
<br>pretty wild there in terms of how you specify a slice--it might be
<br>entirely different.&nbsp; As long as we can translate it!
<p>We plan to unconfuse homonyms, like the different types of do() and
the
<br>different types of eval().&nbsp; For example eval BLOCK will probably
<br>become try BLOCK as that's how other languages are going these days,
<br>and that's what eval BLOCK means.&nbsp; So we may disambiguate that
way.
<p>Typeglobs we would very much like to go away.&nbsp; XS we would dearly
<br>*love* to go away.&nbsp; And I think we can do that, if we can make
Perl a
<br>low-enough level language to have you specify the interfaces.
<p>I had this realization a few years ago when I wrote this thing called
<br>JPL, Java-Perl Lingo.&nbsp; You link Java and Perl interpreters into
the
<br>same process and call back and forward between them.&nbsp; I realized
that
<br>Java had sufficient information to write all the glue to call back
and
<br>forth between Java and Perl, and there was no need to have a glue
<br>language.&nbsp; I thought "that's cool, I wish Perl could do that".
<p>So part of the design of Perl will be that you can specify enough type
<br>information in your function and method signatures to be able to do
<br>that.&nbsp; To be able to produce that glue automatically.
<p>We're going to be standardizing the way that objects are set up.&nbsp;
Not
<br>that we're going to be undoing all the flexibility that you have right
<br>now, but you'll have some standard ways that will be easier and more
<br>efficient.
<p>Perl 5 by design made it easy to use objects, but not easy to write
<br>object classes.&nbsp; We'd like to make it easy to write object classes.
<p>It's becoming obvious that we need a real garbage collector, either
<br>one of our own or we need to be able to relate to one that is
<br>supplied.&nbsp; For example if we compile Perl down to the C# virtual
<br>machine, it provides its own garbage collector.
<p>Exception handling becomes completely object-oriented.&nbsp;&nbsp; You
can still
<br>pretend like it's string-oriented.&nbsp; If you die with a string,
you can
<br>still treat it like an object.&nbsp; This gives you many benefits.
<p>You'll have easier ways to interpolate expressions in strings.&nbsp;
We
<br>might even think, and I haven't thought about this a lot as you can
<br>tell by the question mark on the end, about simplifying the precedence
<br>levels.&nbsp; And the translator can handle that, if it knows about
the
<br>precedence levels in the different languages.&nbsp; So we might be
able to
<br>do that.
<p>[How much complexity can we allow in exchange?]
<p>So the question is, with all this simplification going on, how much
<br>can we get back out?&nbsp; Well, I don't know.&nbsp; We can handle
a certain
<br>amount of complexity so long as we can hide it from people.&nbsp; As
long
<br>as you're not exposed to the part of the complexity that you're not
<br>interested in at the moment, that's a virtue.&nbsp; It goes back to
<br>programming in a subset of Perl: the standard Perl has a certain
<br>level of complexity, and if you put a declaration at the top then you
<br>get the full level of complexity, but you don't *have* to worry about
<br>it.&nbsp; So there are things you can do with the complexity.
<p>[A Tour of the RFCs]
<p>So now let's look at the RFCs.&nbsp; As I said, there are lots of them.
<br>I've sorted out about the first 20 of these, and I've read all but
<br>about the last 50 of them.&nbsp; There are some very interesting things
<br>here, and I'm sad I don't have time to read them all to you.
<p>To let you know the way I'm going through these is.&nbsp; Well, let
me just
<br>show you one as a for instance here.&nbsp; Here's one that probably
won't
<br>be done.&nbsp; [I don't remember which one was on my screen at that
point.]
<p>Let's talk about my classification scheme.&nbsp; There are the first
361,
<br>except for the first 20 which have already disappeared into
<br>subdirectories.
<p>Now you can't read it, but that one says "good", that one says "bad",
<br>and that one says "ugly".&nbsp; So I really am sorting them into the
good,
<br>the bad, and the ugly.&nbsp; There's also a culture directory, and
other
<br>things I don't want to deal with: culture, internals, retracted,
<br>metasyntax.
<p>If you look down into the "good" directory here, I'm not just
<br>classifying them into good, but I'm also giving them grades.&nbsp;
Not
<br>because I want to flunk them, but because I want to sort them in
<br>order.&nbsp; The two grades I'm giving them, the first one is "is this
a
<br>real problem that we need to deal with".&nbsp; And the second grade
is "how
<br>well is the solution specified".&nbsp; And a lot of these say, "I don't
know
<br>how to solve this".&nbsp; This shouldn't be taken to mean I'm castigating
<br>them for brainstorming, but it means I can see them in order.
<p>Yes, it would be great to have higher-resolution time values.&nbsp;
I think
<br>they should be floating point.&nbsp; Some of these I've gone through
and
<br>put notes up to myself: should we modify open() to support objects
and
<br>extensibility?&nbsp; Yes.&nbsp; I think that open() should return a
filehandle
<br>object rather than take a filehandle as a first argument.
<p>Rename the local operator?&nbsp; Yeah, I think we ought to do that.&nbsp;
It
<br>confuses people when we call it local().&nbsp; The problem is, of course,
<br>that this is not a perfect solution--they haven't come up with the
<br>right name here: savetmp, tmpsave, scratchpad, etc.&nbsp; The consideration
<br>for me is how it's used grammatically.&nbsp; It'll often be used with
an
<br>our() declaration.&nbsp; It depends on whether it should come before
or
<br>after the our() keyword.&nbsp; If it came after, you'd say "our temporary
<br>$foo = 2", but if it came before, you'd say "temporarily our $foo =
2".
<p>Yes, we'll reorganize all these funny variables.&nbsp; Rather than put
them
<br>into other globals, we'll make it object-oriented as far as possible.
<p>Here's one that is rated "BF": pretty good problem, rather lousy
<br>solution.&nbsp; There should be a way to tailor error messages to different
<br>languages.&nbsp; We'll have to do that for localization anyway, so
fine.
<p>Here are some from the "bad" directory.&nbsp; (reads from one) ... and
they
<br>want us to solve the halting problem.&nbsp; No.
<p>Highlander variable types.&nbsp; This is an interesting one.&nbsp; The
idea is
<br>that an array is really just a funny name for a reference in the
<br>corresopnding scalar.&nbsp; It makes for some interesting ramifications,
<br>but I think that it would probably be more confusing in the long run.
<p>Multiline comments in Perl.&nbsp; I'm sorry, I was brainwashed by the
Ada
<br>rationale.&nbsp; Ada has comments to the end of the line and I think
that
<br>if your editor can't put a row of sharps down the left, then you need
<br>a better editor.
<p>And so on.
<p>Ugly things are ones that sort-of are good ideas but maybe we need to
<br>think about them.&nbsp; Yeah, we need to talk a lot about threads.&nbsp;
Immediate
<br>subroutines, yes.&nbsp; We need ways of having subroutines that are
<br>evaluated at compile time, but this mechanism probably isn't it.&nbsp;
Lexical
<br>variables made default.&nbsp; Uh, no.
<p>Keep default Perl free of constraints such as warnings and strict.
<br>Yeah, I can argue this one both ways too.&nbsp; Overloadable logic
<br>operators.&nbsp; This has ramifications on a semantic level because
at
<br>least currently the Perl internals don't distinguish between these
<br>funny C-like &amp;&amp; and || and the higher precedence if(), unless()
and so
<br>on.&nbsp; These compile down to the same thing, and it would be strange
to
<br>make some of them behave one way and others the other.&nbsp; We might
allow
<br>it if you declare that you want it this way.
<p>Next one... this is too ugly, something to do with using pod documentation
<br>for specifying test cases and such.
<p>Anyway, that's kinda how I've been going through it.&nbsp; They're great
<br>fun, you should read through them if you want to be entertained.
<br>They're all over the map.&nbsp; Some of them contradict others.&nbsp;
There's no
<br>way we're going to implement them all, because they are
<br>self-contradictory.
<p>In fact, some people have written their own contradictory RFCs.&nbsp;
"We'll
<br>do it this way!"&nbsp;&nbsp; "No, we'll do it this way!"&nbsp; [Bradley
Kuhn laughs on
<br>the front row.] Yes, I was going to point out Brad here.&nbsp; Let's
see:
<br>"Artistic License must be changed" fair enough.&nbsp; "Perl6 License
must be
<br>a bugfix of Perl5's License".&nbsp; "Perl6's Artistic License should
be
<br>GPL/Artistic 2.0", which is a complete change from the old Artistic
<br>License.&nbsp; I haven't actually given this one too much thought yet,
so I
<br>can't tell you whether I approve or not.
<p>A big category in my mind is "things I don't want to think about yet"
<br>and I'm deferring this one.&nbsp; In fact, licensing is probably something
<br>we can defer for a while, at least until we start publishing alphas.
<p>[Perl as a Low-Level Language]
<p>Perl as a low-level language.&nbsp; Polymorphism is your enemy if you're
<br>trying to do low-level programming.&nbsp; If you want to get early
<br>compile-time binding as soon as possible, you want the compiler to
spit
<br>out very efficient code, so you write your loop to declare i as an
<br>int, then by golly you want your compiler to spit out very efficient
C
<br>code.&nbsp; "num" is a number, "str" is a string.&nbsp; For some reason
they're
<br>all coming out to three letters.&nbsp; You'll be able to get nice
<br>declarations like this:
<p>&nbsp; my num $pi :const = 3;
<p>And similarly if you have homogenous arrays or hashes, you'd like to
<br>be able to declare the type of all the elements and have compact
<br>storage.&nbsp; And this will be hugely more efficient than the way
arrays
<br>and hashes are currently stored.&nbsp; Furthermore you specify not
only
<br>what the types are and how they're stored, but give hints to the
<br>compiler like "I'm only going to use these four bits so if you want
to
<br>pack them in tight, go ahead".
<p>If you want to have mathematically compact arrays, multidimensional,
<br>then we'll have some way of declaring those.&nbsp; There's a whole
series
<br>of RFCs of what the mathematicians want out of Perl, if we make them
<br>declare at the top "use MathematicallyFunnyArrays" or something like
<br>that.
<p>Non-homogenous arrays are going to be done primarily through the
<br>object interface.&nbsp; I'd like to borrow the idea of unsafe code
from
<br>C#, where you can go in and do things with low-level pointers, so long
<br>as you're careful.
<p>[Perl as a High-Level Language]
<p>By way of contrast, if Perl's going to become more a high-level
<br>language then polymorphism is your friend.&nbsp; You want to delay
your
<br>binding as long as possible as to what implements what.&nbsp; Perl
has
<br>always been in the business of allowing, but not requiring,
<br>abstraction.&nbsp; We'd like to put in more support for functional
<br>programming, for logic programming, and for what are called "little
<br>languages".
<p>[Perl as a Metalanguage]
<p>The folks at Bell Labs invented this notion, soon after they invented
<br>yacc.&nbsp; "Cool, yacc lets you make a grammar for your own language".&nbsp;
So
<br>all these itty bitty languages sprang up that were for their own
<br>purpose.&nbsp; So each time you wrote a new program, you wrote your
own
<br>language for your program.&nbsp; This was cool except that you had
to learn
<br>the new language each time, and it was always different.&nbsp; We'd
like to
<br>explore the notion of using a big language as a little language.
<p>If it's okay to program in a Perl subset, and you define a subset that
<br>looks like a little language, then how do you get around paying the
<br>price of the generality of the big language?&nbsp; We have ways of
thinking
<br>about that.
<p>[The Perl 4 Approach to Metasyntax]
<p>Perl4's approach to high-level programming, or metasyntax, was the
<br>eval operator.&nbsp; That was what you had, and maybe typeglob assignment
<br>if you were really lucky.&nbsp; Perl5's approach to metasyntax was
much
<br>more general.&nbsp; Not only does it have the eval operator, it has
BEGIN
<br>blocks which are very powerful with the whole notion that you can run
<br>the interpreter at compile-time and do what you jolly well please.
<br>Well, up to a point.
<p>[The Perl 5 Approach to Metasyntax]
<p>By that means, perl5 implemented importation in a completely general
<br>fashion.&nbsp; It allows overloading and overriding of certain builtins
on
<br>the fly as you're compiling.&nbsp; And also there's the concept of
source
<br>filtering.&nbsp; If you declare a source filter at some point, you
can
<br>completely change the language from there on down.&nbsp; There's a
filter,
<br>"use Pythonesque".&nbsp; There's a filter by Damian Conway called
<br>Lingua::Romana::Perligata, which lets you program Perl in Latin.&nbsp;
I
<br>kid you not.
<p>One of the RFCs out there is another of Damian's talks where he
<br>proposes adding quantum mechanical operators which will do quantum
<br>superpositions.&nbsp; Seriously he's proposing this in case some day
we get
<br>quantum computers.&nbsp; Actually, it has some notational convenience
<br>because he has any() and all() operators that work interestingly as
<br>quantifiers.&nbsp; But anyway.
<p>[The Perl 6 Approach to Metasyntax]
<p>In perl6, not only do we have all the perl5 approaches, but we keep
<br>getting asked "we'd like to have a site-wide configuration file that
<br>Perl will read when it starts up".&nbsp; Well, no.&nbsp; Not if it's
going to be
<br>implicit.&nbsp; But if you're willing at the beginning of your site's
Perl
<br>scripts to say "use Policy" then you can have your site policy in
<br>one file, and it can in turn turn on all the strictures that you want.
<br>As long as you declare that, it can be a meta-declaration of all the
<br>other things you want to use.
<p>I intend that the lexer and parser of Perl6 be written in Perl, not
in
<br>C.&nbsp; Perl's low-levelness needs to be made efficient enough so
that the
<br>lexer and parser in Perl will be fast enough.&nbsp; The lexer should
be
<br>written with Perl regular expressions.&nbsp; The parser?&nbsp; If we
can get
<br>away with it, I'd like to do a recursive descent parser because it
can
<br>do much better error diagnostics and we can easily do the last point,
<br>that is add new lexer or parser rules on the fly.
<p>The problem with the source filtering was that it was all or nothing:
<br>you could filter the text as it came through, but then if you just
<br>wanted to tweak the Perl code that was coming through, you had to
<br>parse the Perl code as it was coming through.&nbsp; This lets you use
the
<br>Perl parser for what it's good at, and then tweak it at whatever level
<br>you want.
<p>[Redefining Recognition]
<p>So any point where the lexer or parser is recognizing something, we
<br>will have a hook that lets you redefine how you recognize numbers,
<br>strings, quoted constructs, bracketed constructs like subscripts,
<br>operators, functions, expressions, blocks, lists of blocks like try
<br>... catch ... catch .. catch ... finally, subroutine definitions upto
<br>complete compilation units.&nbsp; That ought to give us enough flexibility
<br>to evolve a little bit further.&nbsp; For a while.
<p>[Unicode Operators?!?]
<p>Now, if you can redefine operators then why not have Unicode
<br>operators.&nbsp; Some of you are squeamish about that.&nbsp; Well,
I say "why
<br>not?"
<p>[Is Malleable Syntax Such a Good Idea?]
<p>The mechanism will be abused, so what?&nbsp; There are a billion
<br>mathematicians out there who are always inventing their own notation.
<br>When they write a program and want one or two mathematical operators,
<br>they'd like to write their script in terms of it.&nbsp; Fine, let them.
<br>They can redefine their own operators, but they're what I call a
<br>swearing operator.&nbsp; If you limit yourself to ASCII, all you can
do is
<br>make yourself longer and longer operators that look weirder and
<br>weirder.
<p>One of the things I like about Tcl is that it's always had a model of
<br>semantic delegation, where the first verb in the command can be kind
<br>of agnostic as to the meaning of the rest of the statement.&nbsp; It
just
<br>hands it off to the next level, and that can work out what the next
<br>level means.&nbsp; This ties back into being able to define little
<br>languages, and is another good use for having these metasyntactic hooks.
<p>This indicates that we're not doing macro processing here, not
<br>rewriting text.&nbsp; We're thinking about putting hooks at the level
where
<br>you can tweak the semantics not just the textual program.
<p>Now hooks like this will be lexically scoped, so there'll be no action
<br>at a distance.&nbsp; If I declare "use this funny-looking Perl code
from
<br>here down in the file" it just changes your file, not someone else's
<br>file.&nbsp; If you want to do it in another file, you have to do it
there
<br>too.
<p>A lot of Perl so far has been "how do I limit the scope of the
<br>complexity?"&nbsp; If you want to do backtracking in logic programming,
<br>it's limited inside a regular expression.&nbsp; So limiting the complexity
<br>is important.&nbsp; And to me, anything is fair so long as you predeclare
<br>it.&nbsp; Even rewriting Perl in Latin.&nbsp; That's crazy, but fair.&nbsp;
I think
<br>that's okay.
<p>Things we must do: we must manage the documentation well, so if people
<br>want to chase down that complexity.&nbsp; They look at this new thing,
they
<br>see the declaration at the top and it says "use this funny syntactic
<br>module".&nbsp; Gotta make sure the documentation is there and easily
found.
<p>And we have to manage the warpage at the semantic level, where there
<br>are interactions between modules.
<p>[Other subjects]
<p>And there are other things we could talk about, but we're out of time.
<br>I'd like to leave you with something that popped up on my screensaver:
<br>"never promise to complete a project within six months of the end of
<br>the year, in either direction".&nbsp; So we won't.
<p>I don't know how long we can go here, but I'd be quite glad to take
<br>questions.&nbsp; I presume that when they turn down the lights that'll
be a
<br>subtle hint.
<p>(inaudible question)
<p>My current leaning is that I really like the new ithreads model
<br>because I think it simplifies the way you can think about it.&nbsp;
For
<br>those of you who are not aware, there are two models of threading in
<br>perl5.&nbsp; One is more of your standard threading model, called pthreads,
<br>where everything is shared (more or less) by default.&nbsp; That has
<br>advantages in terms of efficiency, but not as much as you'd think.
<br>There's another threading model, ithreads, which is more like a fork
<br>inside the process.&nbsp; That could be inefficient, but I think if
we do
<br>what we're thinking of doing with copy-on-write semantics then it will
<br>not be as inefficient as all that to clone a new thread, and I think
<br>in some ways it's much safer to assume that all your global variables
<br>are not shared and make you specifically declare all the things that
<br>you want shared and how you want them shared.&nbsp; So that's my leaning.
<br>I do expect that both models will be there, up to and including
<br>sharing everything.
<p>(inaudible question)
<p>You're too obvious.&nbsp; The question is: what languages are we
<br>considering for writing perl6 in.&nbsp; As I said, the parser and lexer
I
<br>want to write in Perl.&nbsp; I'm under no illusions that we can write
the
<br>runtime engine in Perl.&nbsp; Especially the interpreter.&nbsp; That
would be
<br>silly.
<p>I think at the moment that we are leaning toward writing it in C but
<br>with some amount of preprocessing of our own devising, which manages
<br>some things.&nbsp; Maybe we're reinventing some of C++, but while there's
<br>some interest in the Perl community in using C++, but not that much.
<p>Yes, Bradley says "there's some interest in using Java".&nbsp; Well,
yes
<br>there is.&nbsp; Let me say that we're specifically thinking about not
just
<br>targeting a C back end, but also a Java backend and a C# backend.&nbsp;
And
<br>not just slapping it on at the end, but thinking in the design about
<br>how we divide up the opcodes to make it map nicely onto these other
<br>virtual machines as well as onto a more C-ish thing.
<p>(inaudible question)
<p>Which garbage collection methods are we looking into?&nbsp; That's one
of
<br>those things that we're deferring on purpose.&nbsp; We currently use
a
<br>reference counting methods which has some nice features and some
<br>not-so-nice features.&nbsp; There's a number of different garbage
<br>collection algorithms out there, which have different features from
<br>your basic mark-and-sweep to generational and hybrid approaches.
<p>What we're hoping is that we can keep the interface generic enough so
<br>that we can plug different garbage collectors in.&nbsp; Part of the
reason
<br>for having a preprocessor for our own language is that we can write
it
<br>generically enough that we can preprocess it into C or Java or
<br>whatever, but also that we can preprocess it into handling whatever
<br>garbage collector that virtual machine wanted.&nbsp; Some virtual machines
<br>specify their own garbage collector, and some don't.
<p>(inaudible question)
<p>The question is: what do I want to say about XML and Unicode.&nbsp;
We've
<br>had XML and Unicode support in one way or another in Perl for some
<br>time now.&nbsp; The XML support is pretty heavily used, and there's
been an
<br>XML mailing list for several years, and there are a lot of XML modules
<br>for Perl.&nbsp; Some work better than others, and there's some talk
about
<br>what needs to be done to make them work better.
<p>In some ways there's an impedance mismatch between XML and Perl.&nbsp;
If
<br>you take a parser written in C and hook it up to Perl, you end up
<br>building all these object hierarchies that use up a lot of memory and
<br>it runs real slow.&nbsp; Part of what I didn't go into in the object
design
<br>is that if there are standard ways of mapping what look like Perl
<br>objects onto low-level C-style objects so that where you could quickly
<br>load them in and store them compactly in the way that C or C++ could
<br>do, then you could speed up things like XML parsers.
<p>Unicode is required to support XML.&nbsp; Perl 5.6 supports Unicode,
for
<br>some definition of supports.&nbsp; The story on Unicode is basically
that
<br>Perl's model of characters is going to be Unicode-based.&nbsp; Even
if
<br>there are different encodings floating around inside Perl, in the
<br>abstract you look at a character and it has a particular character
<br>number and it has a length of 1, regardless of how it is encoded.&nbsp;
And
<br>we carry this abstraction completely throug the language itself, and
<br>the only place we have to worry what the real encoding is, is in
<br>interfaces to the outside world, or in older Perl modules that were
<br>making assumptions about bytes.
<p>So we've got a pretty good migration path set out on that, and it's
<br>pretty much there for Perl 5.6.&nbsp; Perl 5 characters are always
coded
<br>internally in utf8 or in bytes, and it keeps track of which it is for
<br>you.&nbsp; IN Perl 6, since we have the vtable approach to the objects,
we
<br>can have different encodings and mix and match.&nbsp; This gives us
a great
<br>deal of scalability and flexibility.
<p>Suppose you want to shoehorn Perl into your Pilot or your TV set top
<br>box.&nbsp; You probably will say "there's only one internal format
for
<br>strings, maybe utf8".&nbsp; If anything else comes along in another
form,
<br>then you'll just translate it.&nbsp; That's probably not so efficient.&nbsp;
On
<br>the other hand, a big server pulling in all sorts of stuff might have
<br>encodings going around: utf8, utf16, utf32, arrays of integers, big5,
<br>shift-JIS, whatever.&nbsp; All this stuff floating around in there,
and if you
<br>have to convert then you do it lazily to what you need.&nbsp; If you
really
<br>want everything to be fast, you run a complete crossbar, where you
can
<br>directly translate anything to anything else.&nbsp; It'll run really
fast.
<br>It'll be really big, but Moore's Law is on our side.
<p>You get that scalability, where you can make the choices trading off
<br>more implementation for speed.&nbsp; So that's the direction we're
heading
<br>with Unicode.
<p>(long question)
<p>That's a very good question.&nbsp; I don't know the answers.&nbsp; I
can tell
<br>you my basic philosophy on all these things: I'd like to have my cake
<br>and eat it too.
<p>(audient interjection)
<p>Component models are very interesting and very important for some
<br>people, and I think they ought to be supported.&nbsp; I don't know
what to
<br>tell you.&nbsp; Activestate has already been looking at putting perl5
into
<br>the component model on Windows.&nbsp; And If we can program down to
the C#
<br>engine, then we get the integration for free.
<br>&nbsp;
<p>Okay, thank you very much.
<p>(applause).
<br>&nbsp;
<br>&nbsp;
</body>
</html>
