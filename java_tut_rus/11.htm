<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Глава 11</TITLE>
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<B><FONT FACE="Times New Roman" SIZE=4><P>Глава 11</P>
<P>Легковесные процессы и синхронизация</P>
</B></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Параллельное программирование, связанное с использованием легковесных процессов, или подпроцессов  (multithreading,  light-weight processes) — концептуальная парадигма, в которой вы разделяете свою программу на два или несколько процессов, которые могут исполняться одновременно. </P>
<P>ЗАМЕЧАНИЕ</P>
<P ALIGN="JUSTIFY">Во многих средах параллельное выполнение заданий представлено в том виде, который в операционных системах называется многозадачностью. Это совсем не то же самое, что параллельное выполнение подпроцессов. В многозадачных операционных системах вы имеете дело с полновесными процессами, в системах с параллельным выполнением подпроцессов отдельные задания называются легковесными процессами (lig</FONT><FONT SIZE=2>ht-weight processes, threads). </P>

</FONT><B><FONT FACE="Times New Roman"><P>Цикл обработки событий в случае единственного подпроцесса</P>
</B></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">В системах без параллельных подпроцессов используется подход, называемый циклом обработки событий. В этой модели единственный подпроцесс выполняет бесконечный цикл, проверяя и обрабатывая возникающие события. Синхронизация между различными частями программы происходит в единственном цикле обработки событий. Такие среды называют синхронными управляемыми событиями системами. Apple Macintosh, Microsoft Windows, X11/Mo</FONT><FONT SIZE=2>t</FONT><FONT FACE="Times New Roman" SIZE=2>if — все эти среды построены на модели с циклом обработки событий.</P>
<P ALIGN="JUSTIFY">Если вы можете разделить свою задачу на независимо выполняющиеся подпроцессы и можете автоматически переключаться с одного подпроцесса, который ждет наступления события, на другой, которому есть чем заняться, за тот же промежуток времени вы выполните больше работы. Вероятность того, что больше чем одному из подпроцессов одновременно надолго потребуется процессор, мала.</P>
</FONT><B>
<FONT FACE="Times New Roman"><P>Модель легковесных процессов в Java</P>
</B></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Исполняющая система Java в многом зависит от использования подпроцессов, и все ее классовые библиотеки написаны с учетом особенностей программирования в условиях параллельного выполнения подпроцессов. Java использует подпроцессы для того, чтобы сделать среду программирования асинхронной. После того, как подпроцесс запущен, его выполнение можно временно приостановить (suspend). Если подпроцесс остановлен (stop), возобновить его выполнение невозможно.</P>
</FONT><B><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P>Приоритеты подпроцессов</P>
</B><P ALIGN="JUSTIFY">Приоритеты подпроцессов — это просто целые числа в диапазоне от 1 до 10 и имеет смысл только соотношения приоритетов различных подпроцессов. Приоритеты же используются для того, чтобы решить, когда нужно остановить один подпроцесс и начать выполнение другого. Это называется <I>переключением контекста.</I> Правила просты. Подпроцесс может добровольно отдать управление — с помощью явного системного вызова или при блокировании на операциях ввода-вывода, либо он может быть приостановлен принудительно. В первом случае проверяются все остальные подпроцессы, и управление передается тому из них, который готов к выполнению и имеет самый высокий приоритет. Во втором случае, низкоприоритетный подпроцесс, независимо от того, чем он занят, приостанавливается принудительно для того, чтобы начал выполняться подпроцесс с более высоким приоритетом. </P>
</FONT><FONT SIZE=2>
</FONT><B><FONT FACE="Times New Roman" SIZE=2><P>Синхронизация</P>
</B><P ALIGN="JUSTIFY">Поскольку подпроцессы вносят в ваши программы асинхронное поведение, должен существовать способ их синхронизации. Для этой цели в Java реализовано элегантное развитие старой модели синхронизации процессов с помощью <I>монитора.</I></FONT><FONT SIZE=2> </P>

</FONT><B><FONT FACE="Times New Roman" SIZE=2><P>Сообщения</P>
</B><P ALIGN="JUSTIFY">Коль скоро вы разделили свою программу на логические части - подпроцессы, вам нужно аккуратно определить, как эти части будут общаться друг с другом. Java предоставляет для этого удобное средство — два подпроцесса могут “общаться” друг с другом, используя методы wait и notify. Работать с параллельными подпроцессами в Java несложно. Язык предоставляет явный, тонко настраиваемый механизм управления созданием подпроцессов, переключения контекстов, приоритетов, синхронизации и обмена сообщениями между подпроцессами. </P>
</FONT><B>
<FONT FACE="Times New Roman"><P>Подпроцесс</P>
</B></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Класс Thread инкапсулирует все средства, которые могут вам потребоваться при работе с подпроцессами. При запуске Java-программы в ней уже есть один выполняющийся подпроцесс. Вы всегда можете выяснить, какой именно подпроцесс выполняется в данный момент, с помощью вызова статического метода Thread.currentThread. После того, как вы получите дескриптор подпроцесса, вы можете выполнять над этим подпроцессом различные операции даже в том случае, когда параллельные подпроцессы отсутствуют. В очередном нашем примере показано, как можно управлять выполняющимся в данный момент подпроцессом.</P>
</FONT><FONT FACE="Arial Narrow" SIZE=2>
</FONT><B><I><FONT FACE="Courier New" SIZE=2><P>class CurrentThreadDemo {</P>
<P>public static void main(String args[]) { </P>
<P>Thread t = Thread.currentThread();</P>
<P>t.setName("My Thread");</P>
<P>System.out. println("current thread: " + t);</P>
<P>try {</P>
<P>for (int n = 5; n &gt; 0; n--) { </P>
<P>System.out.println(" " + n);</P>
<P>Thread.sleep(1000);</P>
<P>} } </P>
<P>catch (InterruptedException e) { </P>
<P>System.out.println("interrupted");</P>
<P>} </P>
<P>} }</P>
</B></I></FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">В этом примере текущий подпроцесс хранится в локальной переменной t. Затем мы используем эту переменную для вызова метода setName, который изменяет внутреннее имя подпроцесса на “My Thread”, с тем, чтобы вывод программы был удобочитаемым. На следующем шаге мы входим в цикл, в котором ведется обратный отсчет от 5, причем на каждой итерации с помощью вызова метода Thread.sleep() делается пауза длительностью в 1 секунду. Аргументом для этого метода является значение временного интервала в миллисекундах, хотя системные часы на многих платформах не позволяют точно выдерживать интервалы короче 10 миллисекунд. Обратите внимание — цикл заключен в try/catch блок. Дело в том, что метод Thread.sleep() может возбуждать исключение InterruptedException. Это исключение возбуждается в том случае, если какому-либо другому подпроцессу понадобится прервать данный подпроцесс. В данном примере мы в такой ситуации просто выводим сообщение о перехвате исключения. Ниже приведен вывод этой программы:</P>
</FONT><FONT FACE="Arial Narrow" SIZE=2>
</FONT><B><I><FONT FACE="Courier New" SIZE=2><P>С:\&gt; java CurrentThreadDemo</P>
</FONT><FONT FACE="Courier New" SIZE=2><P>current thread: Thread[My Thread,5,main]</P>
<P>5</P>
<P>4</P>
<P>3</P>
<P>2</P>
<P>1</P>
</B></I></FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Обратите внимание на то, что в текстовом представлении объекта Thread содержится заданное нами имя легковесного процесса — My Thread. Число 5 — это приоритет подпроцесса, оно соответствует приоритету по умолчанию, “main” — имя группы подпроцессов, к которой принадлежит данный подпроцесс. </P>
</FONT><FONT SIZE=2>
</FONT><B><P>Runnable</P>
</B><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Не очень интересно работать только с одним подпроцессом, а как можно создать еще один? Для этого нам понадобится другой экземпляр класса Thread. При создании нового объекта Thread ему нужно указать, какой программный код он должен выполнять. Вы можете запустить подпроцесс с помощью любого объекта, реализующего интерфейс Runnable. Для того, чтобы реализовать этот интерфейс, класс должен предоставить определение метода run. Ниже приведен пример, в котором создается новый</FONT><FONT SIZE=2> </FONT><FONT FACE="Times New Roman" SIZE=2>подпроцесс.</P>
</FONT><FONT FACE="Arial Narrow" SIZE=2>
</FONT><B><I><FONT FACE="Courier New" SIZE=2><P>class ThreadDemo implements Runnable {</P>
<P>ThreadDemo() {</P>
<P>Thread ct = Thread.currentThread();</P>
<P>System.out.println("currentThread: " + ct);</P>
<P>Thread t = new Thread(this, "Demo Thread");</P>
<P>System.out.println("Thread created: " + t);</P>
<P>t.start();</P>
<P>try {</P>
<P>Thread.sleep(3000);</P>
<P>} </P>
<P>catch (InterruptedException e) { </P>
<P>System.out.println("interrupted");</P>
<P>}</P>
<P>System.out.println("exiting main thread");</P>
<P>}</P>
<P>public void run() { </P>
<P>try {</P>
<P>for (int i = 5; i &gt; 0; i--) { </P>
<P>System.out.println("" + i);</P>
<P>Thread.sleep(1000);</P>
<P>} } </P>
<P>catch (InterruptedException e) {</P>
<P>System.out.println("child interrupted");</P>
<P>} </P>
<P>System.out.println("exiting child thread");</P>
<P>}</P>
<P>public static void main(String args[]) { </P>
<P>new ThreadDemo();</P>
<P>} }</P>
</B></I></FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Обратите внимание на то, что цикл внутри метода run выглядит точно так же, как и в предыдущем примере, только на этот раз он выполняется в другом подпроцессе. Подпроцесс main с помощью оператора new Thread(this, "Demo Thread") создает новый объект класса</FONT><FONT SIZE=2> </FONT><FONT FACE="Times New Roman" SIZE=2>Thread, причем первый параметр конструктора — this — указывает, что нам хочется вызвать метод run текущего объекта. Затем мы вызываем метод start, который запускает подпроцесс, выполняющий метод run. После этого основной подпроцесс (main) переводится в состояние ожидания на три секунды, затем выводит сообщение и завершает работу. Второй подпроцесс — “Demo Thread” — при этом по-прежнему выполняет итерации в цикле метода run до тех пор пока значение счетчика цикла не уменьшится до нуля. Ниже показано, как выглядит результат работы этой программы этой программы после того, как она отработает 5 секунд.</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P>С:\&gt; java ThreadDemo</P>
</FONT><B><I><FONT FACE="Courier New" SIZE=2><P>Thread created: Thread[Demo Thread,5,main]</P>
<P>5</P>
<P>4</P>
<P>3</P>
<P>exiting main thread</P>
<P>2</P>
<P>1</P>
<P>exiting child thread</P>
</I></FONT>
<FONT FACE="Times New Roman"><P>Приоритеты подпроцессов</P>
</B></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Если вы хотите добиться от Java предсказуемого независимого от платформы поведения, вам следует проектировать свои подпроцессы таким образом, чтобы они по своей воле освобождали процессор.</FONT><FONT SIZE=2> </FONT><FONT FACE="Times New Roman" SIZE=2>Ниже приведен пример с двумя подпроцессами с различными приоритетами, которые не ведут себя одинаково на различных платформах. Приоритет одного из подпроцессов с помощью вызова setPriority устанавливается на два уровня выше Thread. NORM_PRIORITY, то есть, умалчиваемого приоритета. У другого подпроцесса приоритет, наоборот, на два уровня ниже. Оба этих подпроцесса запускаются и работают в течение 10 секунд. Каждый из них выполняет цикл, в котором увеличивается значение переменной-счетчика. Через десять секунд после их запуска основной подпроцесс останавливает их работу, присваивая условию завершения цикла while значение true и выводит значения счетчиков, показывающих, сколько итераций цикла успел выполнить каждый из подпроцессов.</P>
</FONT><FONT SIZE=2>
</FONT><B><I><FONT FACE="Courier New" SIZE=2><P>class Clicker implements Runnable { </P>
<P>int click = 0;</P>
<P>private Thread t;</P>
<P>private boolean running = true;</P>
<P>public clicker(int p) {</P>
<P>t = new Thread(this);</P>
<P>t.setPriority(p);</P>
<P>} </P>
<P>public void run() {</P>
<P>while (running) { </P>
<P>click++;       </P>
<P>} }</P>
<P>public void stop() {</P>
<P>running = false;  }</P>
<P>public void start() {</P>
<P>t.start();</P>
<P>} }</P>
<P>class HiLoPri {</P>
<P>public static void main(String args[]) {</P>
<P>Thread.currentThread().setPriority(Thread.MAX_PRIORITY);</P>
<P>clicker hi = new clicker(Thread.NORM_PRIORITY + 2);</P>
<P>clicker lo = new clicker(Thread.NORM_PRIORITY - 2);</P>
<P>lo.start();</P>
<P>hi.start();</P>
<P>try Thread.sleep(-10000) {</P>
<P>} </P>
<P>catch (Exception e) {</P>
<P>}</P>
<P>lo.stop();</P>
<P>hi.stop();</P>
<P>System.out.println(lo.click + " vs. " + hi.click); </P>
<P>} }</P>
</B></I></FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">По значениям, фигурирующим в распечатке, можно заключить, что подпроцессу с низким приоритетом достается меньше на 25 процентов времени процессора:</P>
</FONT><B><I><FONT FACE="Courier New" SIZE=2><P>C:\&gt;java HiLoPri</P>
<P>304300 vs. 4066666</P>
</B></I></FONT><FONT SIZE=2>
</FONT><B><FONT FACE="Times New Roman"><P>Синхронизация</P>
</B></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Когда двум или более подпроцессам требуется параллельный доступ к одним и тем же данным (иначе говоря, к совместно используемому ресурсу), нужно позаботиться о том, чтобы в каждый конкретный момент времени доступ к этим данным предоставлялся только одному из подпроцессов. Java для такой синхронизации предоставляет уникальную, встроенную в язык программирования поддержку. В других системах с параллельными подпроцессами существует понятие <I>монитора.</I> Монитор — это объект, используемый как защелка. Только один из подпроцессов может в данный момент времени владеть монитором. Когда под-процесс получает эту защелку, говорят, что он <I>вошел</I> в монитор. Все остальные подпроцессы, пытающиеся войти в тот же монитор, будут заморожены до тех пор пока подпроцесс-владелец не выйдет из монитора. </P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">У каждого Java-объекта есть связанный с ним неявный монитор, а для того, чтобы войти в него, надо вызвать метод этого объекта, отмеченный ключевым словом </FONT><B><FONT SIZE=2>synchronized</B></FONT><FONT FACE="Times New Roman" SIZE=2>. Для того, чтобы выйти из монитора и тем самым передать управление объектом другому подпроцессу, владелец монитора должен всего лишь вернуться из синхронизованного метода.</P>
</FONT><FONT SIZE=2>
</FONT><B><I><FONT FACE="Courier New" SIZE=2><P>class Callme {</P>
<P>void call(String msg) {</P>
<P>System.out.println("[" + msg);</P>
<P>try Thread.sleep(-1000) {} </P>
<P>catch(Exception e) {}</P>
<P>System.out.println("]");</P>
<P>} }</P>
<P>class Caller implements Runnable { </P>
<P>String msg;</P>
<P>Callme target;</P>
<P>public Caller(Callme t, String s) { </P>
<P>target = t;</P>
<P>msg = s;</P>
<P>new Thread(this).start();</P>
<P>}</P>
<P>public void run() { </P>
<P>target.call(msg);</P>
<P>} } </P>
<P>class Synch {</P>
<P>public static void main(String args[]) { </P>
<P>Callme target = new Callme();</P>
<P>new Caller(target, "Hello.");</P>
<P>new Caller(target, "Synchronized");</P>
<P>new Caller(target, "World");</P>
<P>}</P>
<P>}</P>
</B></I></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Вы можете видеть из приведенного ниже результата работы программы, что sleep в методе call приводит к переключению контекста между подпроцессами, так что вывод наших 3 строк-сообщений перемешивается:</P>
</FONT><FONT SIZE=2>
</FONT><B><I><FONT FACE="Courier New" SIZE=2><P>[Hello.</P>
<P>[Synchronized</P>
<P>]</P>
<P>[World</P>
<P>] </P>
<P>]</P>
</B></I></FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Это происходит потому, что в нашем примере нет ничего, способного помешать разным подпроцессам вызывать одновременно один и тот же метод одного и того же объекта. Для такой ситуации есть даже специальный термин — </FONT><B><FONT SIZE=2>race condition</B></FONT><FONT FACE="Times New Roman" SIZE=2> (состояние гонки), означающий, что различные подпроцессы пытаются опередить друг друга, чтобы завершить выполнение одного и того же метода. В этом примере для того, чтобы это состояние было очевидным и повторяемым, использован вызов sleep. В реальных же ситуациях это состояние, как правило, трудноуловимо, поскольку непонятно, где именно происходит переключение контекста, и этот эффект менее заметен и не всегда воспроизводятся от запуска к запуску программы. Так что если у вас есть метод (или целая группа методов), который манипулирует внутренним состоянием объекта, используемого в программе с параллельными подпроцессами, во избежание состояния гонки вам следует использовать в его заголовке ключевое слово </FONT><B><FONT SIZE=2>synchronized</B>. </P>

</FONT><B><FONT FACE="Times New Roman"><P>Взаимодействие подпроцессов</P>
</B></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">В Java имеется элегантный механизм общения между подпроцессами, основанный на методах </FONT><B><FONT SIZE=2>wait</B>, <B>notify</B></FONT><FONT FACE="Times New Roman" SIZE=2> и </FONT><B><FONT SIZE=2>notifyAll</B></FONT><FONT FACE="Times New Roman" SIZE=2>. Эти методы реализованы, как final-методы класса Object, так что они имеются в любом Java-классе. Все эти методы должны вызываться только из синхронизованных методов. Правила использования этих методов очень просты:</P>
<P ALIGN="JUSTIFY">• wait — приводит к тому, что текущий подпроцесс отдает управление и переходит в режим ожидания — до тех пор пока другой под-процесс не вызовет метод notify с тем же объектом.</P>
<P ALIGN="JUSTIFY">• notify — выводит из состояния ожидания первый из подпроцессов, вызвавших wait с данным объектом.</P>
<P ALIGN="JUSTIFY">• notifyAll — выводит из состояния ожидания все подпроцессы, вызвавшие wait с данным объектом.</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Ниже приведен пример программы с наивной реализацией проблемы поставщик-потребитель. Эта программа состоит из четырех простых классов: класса Q, представляющего собой нашу реализацию очереди, доступ к которой мы пытаемся синхронизовать; поставщика (класс Producer), выполняющегося в отдельном подпроцессе и помещающего данные в очередь; потребителя (класс Consumer</FONT><FONT SIZE=2>)</FONT><FONT FACE="Times New Roman" SIZE=2>, тоже представляющего собой подпроцесс и извлекающего данные из очереди; и, наконец, крохотного класса PC, который создает по одному объекту каждого из перечисленных классов.</P>
</FONT><FONT SIZE=2>
</FONT><B><I><FONT FACE="Courier New" SIZE=2><P>class Q { </P>
<P>int n;</P>
<P>synchronized int get() {</P>
<P>System.out.println("Got: " + n);</P>
<P>return n;</P>
<P>}</P>
<P>synchronized void put(int n) { </P>
<P>this.n = n;</P>
<P>System.out. println("Put: " + n);</P>
<P>} }</P>
<P>class Producer implements Runnable { </P>
<P>Q q;</P>
<P>Producer(Q q) { </P>
<P>this.q = q;</P>
<P>new Thread(this,&#9;"Producer").start();</P>
<P>}</P>
<P>public void run()&#9;{</P>
<P>int i = 0;</P>
<P>while (true) { </P>
<P>q.put(i++);</P>
<P>} } }</P>
<P>class Consumer implements Runnable { </P>
<P>Q q;</P>
<P>Consumer(Q q) {</P>
<P>this.q = q;</P>
<P>new Thread(this,&#9;"Consumer").start();</P>
<P>}</P>
<P>public void run()&#9;{</P>
<P>while (true) {</P>
<P>q.get();</P>
<P>}</P>
<P>} }</P>
<P>class PC {</P>
<P>public static void main(String args[]) {</P>
<P>Q q = new Q();</P>
<P>new Producer(q);</P>
<P>new Consumer(q);</P>
<P>} }</P>
</B></I></FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Хотя методы put и get класса Q синхронизованы, в нашем примере нет ничего, что бы могло помешать поставщику переписывать данные по того, как их получит потребитель, и наоборот, потребителю ничего не мешает многократно считывать одни и те же данные. Так что вывод программы содержит вовсе не ту последовательность сообщений, которую нам бы хотелось иметь:</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P>С:\&gt; java PC</P>
</FONT><B><I><FONT FACE="Courier New" SIZE=2><P>Put: 1</P>
<P>Got: 1</P>
<P>Got: 1</P>
<P>Got: 1</P>
<P>Got: 1</P>
<P>Got: 1</P>
<P>Put: 2</P>
<P>Put: 3</P>
<P>Put: 4</P>
<P>Put: 5</P>
<P>Put: 6</P>
<P>Put: 7</P>
<P>Got: 7</P>
</B></I></FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Как видите, после того, как поставщик помещает в переменную n значение 1, потребитель начинает работать и извлекает это значение 5 раз подряд. Положение можно исправить, если поставщик будет при занесении нового значения устанавливать флаг, например, заносить в логическую переменную значение true, после чего будет в цикле проверять ее значение до тех пор пока поставщик не обработает данные и не сбросит флаг в false. </P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Правильным путем для получения того же результата в Java является использование вызовов wait и notify для передачи сигналов в обоих направлениях. Внутри метода get мы ждем (вызов wait), пока Producer не известит нас (notify), что для нас готова очередная порция данных. После того, как мы обработаем эти данные в методе get, мы извещаем объект класса Producer (снова вызов notify) о том, что он может передавать следующую порцию данных. Соответственно, внутри метода put, мы ждем (wait), пока Consumer не обработает данные, затем мы передаем новые данные и извещаем (notify) об этом объект-потребитель. Ниже приведен переписанный указанным образом класс Q.</P>
</FONT><FONT SIZE=2>
</FONT><B><I><FONT FACE="Courier New" SIZE=2><P>class Q {</P>
<P>int n;</P>
<P>boolean valueSet = false;</P>
<P>synchronized int get() {</P>
<P>if (!valueSet)</P>
<P>try wait();</P>
<P>catch(InterruptedException e):</P>
<P>System.out.println("Got: " + n);</P>
<P>valueSet = false;</P>
<P>notify();</P>
<P>return n;</P>
<P>}</P>
<P>synchronized void put(int n) {</P>
<P>if (valueSet)</P>
<P>try wait(); catch(InterruptedException e);</P>
<P>this.n = n;</P>
<P>valueSet = true;</P>
<P>System.out.println("Put: " + n);</P>
<P>notify();</P>
<P>} }</P>
</B></I></FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P>А вот и результат работы этой программы, ясно показывающий, что синхронизация достигнута.</P>
<P>С:\&gt; java Pcsynch</P>
</FONT><B><I><FONT FACE="Courier New" SIZE=2><P>Put: 1</P>
<P>Got: 1</P>
<P>Put: 2</P>
<P>Got: 2</P>
<P>Put: 3</P>
<P>Got: 3</P>
<P>Put: 4</P>
<P>Got: 4</P>
<P>Put: 5</P>
<P>Got: 5</P>
</I></FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P>Клинч (deadlock)</P>
</B><P ALIGN="JUSTIFY">Клинч — редкая, но очень трудноуловимая ошибка, при которой между двумя легковесными процессами существует кольцевая зависимость от пары синхронизированных объектов. Например, если один подпроцесс получает управление объектом X, а другой — объектом Y, после чего Х пытается вызвать любой синхронизированный метод Y,&#9;этот вызов, естественно блокируется. Если при этом и Y попытается вызвать</FONT><FONT SIZE=2> </FONT><FONT FACE="Times New Roman" SIZE=2>синхронизированный метод X, то программа с такой структурой подпроцессов окажется заблокированной навсегда. В самом деле, ведь для того, чтобы один из подпроцессов захватил нужный ему объект, ему нужно снять свою блокировку, чтобы второй подпроцесс мог завершить работу.</P>
</FONT><B>
<FONT FACE="Times New Roman"><P>Сводка функций программного интерфейса легковесных процессов</P>
</B></FONT><FONT FACE="Times New Roman" SIZE=2><P>Ниже приведена сводка всех методов класса Thread, обсуждавшихся в этой главе.</P>
<B><P>Методы класса</P>
</B><P>Методы класса — это статические методы, которые можно вызывать непосредственно с именем класса Thread.</P>
</FONT><U><FONT SIZE=2><P>currentThread</P>
</U></FONT><FONT FACE="Times New Roman" SIZE=2><P>Статический метод currentThread возвращает объект Thread, выполняющийся в данный момент.</P>
</FONT><U><FONT SIZE=2><P>yield</P>
</U></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Вызов метода yield приводит к тому, что исполняющая система переключает контекст с текущего на следующий доступный подпроцесс. Это один из способов гарантировать, что низкоприоритетные подпроцессы когда-нибудь получат управление.</P>
</FONT><U><FONT SIZE=2><P>sleep(int n)</P>
</U></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">При вызове метода sleep исполняющая система блокирует текущий подпроцесс на n миллисекунд. После того, как этот интервал времени закончится, подпроцесс снова будет способен выполняться. В большинстве исполняющих систем Java системные часы не позволяют точно выдерживать паузы короче, чем 10 миллисекунд.</P>
<B><P>Методы объекта</P>
</B></FONT><U><FONT SIZE=2><P>start</P>
</U></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Метод start говорит исполняющей системе Java, что необходимо создать системный контекст подпроцесса и запустить этот подпроцесс. После вызова этого метода в новом контексте будет вызван метод run вновь созданного подпроцесса. Вам нужно помнить о том, что метод start с данным объектом можно вызвать только один раз.</P>
</FONT><U><FONT SIZE=2><P>run</P>
</U></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Метод run — это тело выполняющегося подпроцесса. Это — единственный метод интерфейса Runnable. Он вызывается из метода start после того, как исполняющая среда выполнит необходимые операции по инициализации нового подпроцесса. Если происходит возврат из метода run, текущий подпроцесс останавливается</FONT><FONT SIZE=2>.</P>
<U><P>stop</P>
</U></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Вызов метода stop приводит к немедленной остановке подпроцесса. Это — способ мгновенно прекратить выполнение текущего подпроцесса, особенно если метод выполняется в текущем подпроцессе. В таком случае строка, следующая за вызовом метода stop, никогда не выполняется, поскольку контекст подпроцесса “умирает” до того, как метод stop возвратит управление. Более аккуратный способ остановить выполнение подпроцесса — установить значение какой-либо переменной-флага, предусмотрев в методе run код, который,</FONT><FONT SIZE=2> </FONT><FONT FACE="Times New Roman" SIZE=2>проверив состояние флага, завершил бы выполнение подпроцесса.</P>
</FONT><U><FONT SIZE=2><P>suspend</P>
</U></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Метод suspend отличается от метода stop тем, что метод приостанавливает выполнение подпроцесса, не разрушая при этом его системный контекст. Если выполнение подпроцесса приостановлено вызовом suspend, вы можете снова активизировать этот подпроцесс, вызвав метод resume.</P>
</FONT><U><FONT SIZE=2><P>resume</P>
</U></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Метод resume используется для активизации подпроцесса, приостановленного вызовом suspend. При этом не гарантируется, что после вызова resume подпроцесс немедленно начнет выполняться, поскольку в этот момент может выполняться другой более высокоприоритетный процесс. Вызов resume лишь делает подпроцесс способным выполняться, а то, когда ему будет передано управление, решит планировщик.</P>
</FONT><U><FONT SIZE=2><P>setPriority(int p)</P>
</U></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Метод setPriority устанавливает приоритет подпроцесса, задаваемый целым значением передаваемого методу параметра. В классе Thread есть несколько предопределенных приоритетов-констант: MIN_PRIORITY, NORM_PRIORITY и MAX_PRIORITY, соответствующих соответственно значениям 1, 5 и 10. Большинство пользовательских приложений должно выполняться на уровне NORM_PRIORITY плюс-минус 1. Приоритет фоновых заданий, например, сетевого ввода-вывода или перерисовки экрана, следует устанавливать в MIN_PRIORITY. Запуск подпроцессов на уровне MAX_PRIORITY требует осторожности. Если в подпроцессах с таким уровнем приоритета отсутствуют вызовы sleep или yield, может оказаться, что вся исполняющая система Java перестанет реагировать на внешние раздражители.</P>
</FONT><U><FONT SIZE=2><P>SetPriority</P>
</U></FONT><FONT FACE="Times New Roman" SIZE=2><P>Этот метод возвращает текущий приоритет подпроцесса — целое значение в диапазоне от 1 до 10.</P>
</FONT><U><FONT SIZE=2><P>setName(String name)</P>
</U></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Метод setName присваивает подпроцессу указанное в параметре имя. Это помогает при отладке программ с параллельными подпроцессами. Присвоенное с помощью setName имя будет появляться во всех трассировках стека, которые выводятся при получении интерпретатором неперехваченного исключения.</P>
</FONT><U><FONT SIZE=2><P>getName</P>
</U></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Метод getName возвращает строку с именем подпроцесса, установленным с помощью вызова setName.</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Есть еще множество функций и несколько классов, например, ThreadGroup и SecurityManager, которые имеют отношение к подпроцессам, но эти области в Java проработаны еще не до конца. Скажем лишь, что при необходимости можно получить информацию об этих интерфейсах из документации по</FONT><FONT SIZE=2> JDK API.</P>
</FONT><B>
<FONT FACE="Times New Roman"><P>А дорога дальше вьется</P>
</B></FONT><FONT FACE="Times New Roman" SIZE=2><P ALIGN="JUSTIFY">Простые в использовании встроенные в исполняющую среду и в синтаксис Java легковесные процессы — одна из наиболее веских причин, по которым стоит изучать этот язык. Освоив однажды параллельное программирование, вы уже никогда не захотите возвращаться назад к программированию с помощью модели, управляемой событиями. После того, как вы освоились с основами программирования на Java, включая создание классов, пакетов, и модель легковесных процессов, для вас не составит труда разобраться в той коллекции Java-классов, к обсуждению которой мы сейчас приступим.</P>
</FONT><FONT SIZE=2></FONT></BODY>
</HTML>
