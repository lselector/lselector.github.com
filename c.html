<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Description" content="Machine Learning, AI, Data Science, Python, Jupyter, Linux, Cloud, SQL">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; U) [Netscape]">
   <title>C.html</title>
<!--
"Description" content="Machine Learning, AI, Data Science, Python, Jupyter, Linux, Cloud, SQL"
-->
<link REL="stylesheet" TYPE="text/css" HREF="style0.css" >
</head>
<body text="#000000" bgcolor="#FFFFFF">
<a NAME="top"></a>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><b><font color="#CC0000">LevSelector.com</font></b><spacer type=block width=1 height=1></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><spacer type=block width=1 height=1><b><font color="#CC0000">New
York</font></b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<tr>
<td><spacer type=block width=1 height=1></td>
</tr>

<tr>
<td BGCOLOR="#66CCFF"><spacer type=block width=1 height=1></td>
</tr>

<tr>
<td><spacer type=block width=1 height=1></td>
</tr>
</table>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" BGCOLOR="#C4ECFF" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><spacer type=block width=1 height=1><b><a href="index.html">home</a>
> C</b></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><spacer type=block width=1 height=1><b></b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<tr>
<td><spacer type=block width=1 height=1></td>
</tr>

<tr>
<td BGCOLOR="#51C7FF"><spacer type=block width=1 height=1></td>
</tr>

<tr>
<td><spacer type=block width=1 height=1></td>
</tr>
</table>

<table BORDER=0 CELLSPACING=0 CELLPADDING=6 >
<tr>
<td><b><font color="#CC0000">C programming language</font></b></td>

<td></td>

<td><b><font color="#CC0000">Other pages</font></b></td>
</tr>

<tr>
<td ALIGN=LEFT VALIGN=TOP><font color="#6699CC">• <a href="#intro">intro</a></font>
<br><font color="#6699CC">• <a href="#books">books</a></font>
<br><font color="#6699CC">• <a href="#tutorials">tutorials</a></font>
<br><font color="#6699CC">• <a href="#misc">misc</a></font></td>

<td ALIGN=LEFT VALIGN=TOP><font color="#6699CC">• <a href="#C-tutorial_part1">C-tutorial
part1</a></font>
<br><font color="#6699CC">• <a href="#C-tutorial_part2">C-tutorial part2</a></font>
<br><font color="#6699CC">• <a href="#C-tutorial_part3">C-tutorial part3</a></font>
<br><font color="#6699CC">• <a href="#C-tutorial_part4">C-tutorial part4</a></font>
<br><font color="#6699CC">• <a href="#C-tutorial_part5">C-tutorial part5</a></font></td>

<td ALIGN=LEFT VALIGN=TOP><font color="#6699CC">• <b><a href="c++.html">C++</a></b></font>
<br><font color="#6699CC">• <a href="c++_tut_1.html">C++ tutorial #1</a></font>
<br><font color="#6699CC">• <a href="c++_tut_2.html">C++ tutorial #2</a></font></td>
</tr>
</table>
<a NAME="intro"></a>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" BGCOLOR="#C4ECFF" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><b>intro</b></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><b><a href="index.html">home</a> - <a href="#top">top
of the page</a> - </b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<table BORDER=0 CELLSPACING=0 CELLPADDING=3 >
<tr>
<td><img SRC="images/clinton.jpg" HSPACE=12 BORDER=0 height=185 width=186></td>

<td ALIGN=LEFT VALIGN=TOP><b><font color="#CC0000">Dennis Richie shaking
hands with President Clinton</font></b>
<br>
<b><font color="#CC0000">the day he received the National Medal of
Technology for creating C.</font></b> <br>
• <a href="http://www.youtube.com/watch?v=LXZ1OL2U3lY">youtube video - Ken Thomson and Dennis Riche</a> receiving the award - 1998
<p> &bull; <a href="http://directory.google.com/Top/Computers/Programming/Languages/C/">http://directory.google.com/Top/Computers/Programming/Languages/C/</a> - google directory of links <br>
  • <a href="http://en.wikipedia.org/wiki/C_(programming_language)">http://en.wikipedia.org/wiki/C_(programming_language)</a><br>
  • <a href="http://www.ioccc.org/index.html">www.ioccc.org</a> - The
  International Obfuscated C Code Contest <br>
  • <a href="http://www.ioccc.org/years.html">www.ioccc.org/years.html</a> - Previous IOCCC Winners <br>
  • <a href="http://cm.bell-labs.com/cm/cs/who/dmr/primevalC.html">http://cm.bell-labs.com/cm/cs/who/dmr/primevalC.html</a> - Very early C compilers and language</td>
</tr>
</table>
<a NAME="books"></a>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" BGCOLOR="#C4ECFF" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><b>books</b></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><b><a href="index.html">home</a> - <a href="#top">top
of the page</a> - </b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<p><b><u><font color="#CC0000">Books:</font></u></b>
<br><font color="#CC0000">&nbsp;- C Programming Language - by Brian W.
Kernighan, Dennis Ritchie (1978 - 1st, 1983, 1988 - 2nd ed.)</font>
<br><font color="#CC0000">&nbsp;- The C Answer Book (2nd Edition) - by
Clovis Tondo,&nbsp; Scott Gimpel, Brian Kernighan (1988)</font>
<br><font color="#CC0000">&nbsp;- C: A Reference Manual (5th Edition)-
by: Samuel P., III Harbison, Guy L., Jr. Steele (2002)</font>
<br><font color="#CC0000">&nbsp;- TheUNIX Programming Environment - by
Brian W. Kernighan, Rob Pike (1984)</font>
<p><a NAME="tutorials"></a>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" BGCOLOR="#C4ECFF" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><b>tutorials</b></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><b><a href="index.html">home</a> - <a href="#top">top
of the page</a> - </b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<p>• <a href="http://www.cyberdiem.com/vin/learn.html">http://www.cyberdiem.com/vin/learn.html</a>
- C / C++ tutorial
<br>• <a href="http://www.kulichki.com/moshkow/CTOTOR/">http://www.kulichki.com/moshkow/CTOTOR/</a>
- Moshkov's library - programming, C/C++/Unix
<p><a NAME="misc"></a>
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" BGCOLOR="#C4ECFF" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><b>misc</b></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><b><a href="index.html">home</a> - <a href="#top">top
of the page</a> - </b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<p>&bull; <a href="http://www.parashift.com/c++-faq-lite/mixing-c-and-cpp.html">http://www.parashift.com/c++-faq-lite/mixing-c-and-cpp.html</a> - 
  Calling C++ from C and vice versa<br>
• <a href="http://www.parasoft.com/products/insure/index.htm">www.parasoft.com/products/insure/index.htm</a> - Insure++ Automatic Runtime Error Detection <br>
  • <a href="http://www.progsource.com/c_windows.html">www.progsource.com/c_windows.html</a> - The Programmer's Source - Windows Development C Resources <br>
  • <a href="http://www.lysator.liu.se/c/c-www.html">/www.lysator.liu.se/c/c-www.html</a> - Other Sources <br>
  • <a href="http://www2.iro.umontreal.ca/~ratib/code/">www2.iro.umontreal.ca/~ratib/code/</a> - Codepage 2.3 - Subject index of C programming resources on the WWW <br>
  • <a href="http://www.cprogramming.com/">www.cprogramming.com</a> -
  Programming in C and C++ - to help beginner 'coders' <br>
  • <a href="http://www.europa.com/~viper/">www.europa.com/~viper</a> - Viper's C/C++ Web Page - Network,windows,graphics,sound <br>
  • <a href="http://www.programmersheaven.com/zone3/index.htm">www.programmersheaven.com</a> - Programmers Heaven - C / C++ Zone <br>
  • <a href="http://www.nerdworld.com/nw93.html">www.nerdworld.com/nw93.html</a> - C Programming Resources From Nerd World Media <br>
  • <a href="http://www.cast.msstate.edu/~billy/c-prog.html">www.cast.msstate.edu/~billy/c-prog.html</a> - C Programming Resources <br>
  • <a href="http://www.redrival.com/bigt/">www.redrival.com/bigt</a> - Big T's C/C++ Resource Center. <br>
  • <a href="http://www.prineas.com/Links/C/index.html">www.prineas.com/Links/C/index.html</a> - Essential C/C++ Links <br>
  • <a href="http://www.strangecreations.com/library/c/index.htm">www.strangecreations.com/library/c/index.htm</a> - Virtual Library - C and C++ <br>
  • <a href="http://www.infopoll.com/infopoll/surveys/s4598.htm">www.infopoll.com/infopoll/surveys/s4598.htm</a> - Borland C++ Survey <br>
  • <a href="http://www.geocities.com/SiliconValley/Vista/7336/robcstf.htm">www.geocities.com/SiliconValley/Vista/7336/robcstf.htm</a> - Robin's C Programming <br>
  • <a href="http://www.softpanorama.org/Lang/c.shtml">www.softpanorama.org/Lang/c.shtml</a> - Softpanorama Universitys Annotated C Webliography <br>
  • <a href="http://www.angelfire.com/tx2/cplus/index.html">www.angelfire.com/tx2/cplus/index.html</a> - The C/C++ webpage for all levels <br>
  • <a href="http://members.tripod.com/codist/">http://members.tripod.com/codist</a> - The Codist - a survey of source code comprehension tools <br>
  • <a href="http://www.tek-tips.com/gthreadminder.cfm/lev2/4/lev3/32/pid/205">www.tek-tips.com/gthreadminder.cfm/lev2/4/lev3/32/pid/205</a> - C Language forum at Tek-Tips - forums and mutual help system for computer
  professionals. <br>
  • <a href="http://jvcpp.8m.com/">ttp://jvcpp.8m.com</a> - The All-New
  C Programmer's Paradise (also C++ and JavaScript) <br>
  . • <a href="http://www.geocities.com/SiliconValley/Haven/5601/">www.geocities.com/SiliconValley/Haven/5601</a> - C N Stuff Home Page - Links, code examples and lots of other stuff. <br>
  • <a href="http://www.qb45.com/c/">www.qb45.com/c</a> - Future Software
  - files, links, tutorials, message board; all automatically updated by
  visitors. <br>
  • <a href="http://homestead.juno.com/hawraned/index.html">http://homestead.juno.com/hawraned/index.html</a> - Two Bit Software - Translates C software to Java, Applesoft BASIC software
  to ANSI C with extensions. <br>
  • <a href="http://www.allexperts.com/getExpert.asp?Category=1587">www.allexperts.com/getExpert.asp?Category=1587</a> - Allexperts C Programming Q&amp;A - Volunteer experts answer your detailed
  one-on-one questions. <br>
  • <a href="http://www.angelfire.com/sc/electron">www.angelfire.com/sc/electron</a> - The C Coders Home Page - A collection of resources including support
  for unix/dos systems,win32,sockets, and game programming. <br>
  • <a href="http://lclint.cs.virginia.edu/">http://lclint.cs.virginia.edu</a> - LCLint - Tool for statically checking C programs, GPL. <br>
  • <a href="http://www.flamingolingo.com/programming.c/">www.flamingolingo.com/programming.c/</a> - Programming.c Directory of programming sites (C, C++, Java, COBOL, Basic,
  COM, Pascal, etc.) <br>
  • <a href="http://www.genitor.com/resources/">www.genitor.com/resources</a> - Genitor Corporation Developer Resources <br>
  • <a href="http://hermetic.nofadz.com/cfunlib.htm">http://hermetic.nofadz.com/cfunlib.htm</a> - C/C++ Programming and C function libraries for calendar date conversion
  and multidimensional dynamic array allocation; links. <br>
  • <a href="http://anubis.dkuug.dk/JTC1/SC22/WG14/">http://anubis.dkuug.dk/JTC1/SC22/WG14</a> - Home of the C standard group <br>
  • <a href="http://www.cs.wisc.edu/csl/doc/info/unix-software/programming/debuggers/">http://www.cs.wisc.edu/csl/doc/info/unix-software/programming/debuggers/</a> - debuggers <br>
  • <b><font color="#CC0000">dbx</font></b> is the Berkeley UNIX symbolic
  debugger. It is available on Solaris and some other Unix-es. Not supported
  on Linux. Convenient primarily because it is not X-Windows based. Installed
  Location: /usr/bin/dbx .&nbsp; Running the code: Compile and link your
  code with the -g flag to incorporate debugging information. Then, run your
  code under the debugger.&nbsp; For example, dbx a.out .&nbsp; Core dumps
  can also be probed using dbx to determine the cause of the crash. <br>
  • <b><font color="#CC0000">gdb</font></b> is the standard GNU debugger.
  Although originally designed to operate with the GNU C compiler (gcc),
  gdb can be used to debug programs compiled from a variety of different
  compilers, including vendor-supplied C and Fortran compilers on several
  platforms (if compiled with debugger symbol information). Emacs includes
  a GDB mode for simultaneously debugging and editing programs. <br>
  • <b><font color="#CC0000">ddd</font></b> is a wrapper around the GDB,
  DBX, or XDB debuggers. In addition to the command-line interface of the
  dependent debugger, DDD provides a common graphical user interface to support
  debugging tasks. The DDD graphical data display allows for interactive
  exploration of data structures.
<p><a NAME="C-tutorial_part1"></a>
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" BGCOLOR="#C4ECFF" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><b>C-tutorial part 1</b></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><b><a href="index.html">home</a> - <a href="#top">top
of the page</a> - </b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<p>The 'C' programming language was designed and developed by Brian Kernighan,
and Dennis Ritchie at The Bell Research Labs. It was first implemented
in assembler on a Digital Equipment Corporation PDP-7. Once a simple assembler
version was working it was possible to rewrite the compiler in 'C' itself.
This was done in short order and therefore as soon as the PDP-11 was introduced
by DEC it was only necessary to change the code generator section of the
compiler and the new machine had a compiler in just a few weeks. 'C' was
then used to implement the UNIX o/s. This means, that a complete UNIX can
be ported to a new machine in literally just a few months by a small team
of competent programmers.
<p>Create file <b><font color="#3333FF">hello.c</font></b>:
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#include &lt;stdio.h>
<p>char *format = "%s",
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *hello = "Hello World...\n";
<p>main() {
<br>&nbsp; printf ( format, hello );
<br>}</td>
</tr>
</table>
Now type:
<br><b><font color="#3333FF">cc -o hello hello.c</font></b>
<br>Now type:
<br><b><font color="#3333FF">hello</font></b>
<br>The computer will print
<br><b><font color="#3333FF">Hello World...</font></b>
<p>Although we did everything with one command, in fact the compilation
process consisted of several stages (pre-processing, compiling, assembling,
linking). We can go through them step-by-step:
<table BORDER=0 CELLSPACING=0 CELLPADDING=2 BGCOLOR="#FFFFCC" >
<tr>
<td>Pre-processor - replaces the line&nbsp; <b><font color="#CC0000">#include
&lt;stdio.h> </font></b>with the file <b><font color="#CC0000">stdio.h</font></b>
(standard input/output headers) from the include files library (from directory
/usr/include/). To see just this step - use the following commands:
<br>
<b><font color="#3333FF">cc -E hello.c</font></b>
<br><b><font color="#3333FF">view hello.i</font></b>
<br>You will see that a number of lines of text have been added at the
front of the hello.c program from the file called <b><font color="#CC0000">/usr/include/stdio.h</font></b>
:
<br><b><font color="#3333FF">view /usr/include/stdio.h</font></b>
<br>Next stage&nbsp; - compile into an assembler code program. Use the
following commands
<br><b><font color="#3333FF">cc -S hello.c</font></b>
<br><b><font color="#3333FF">view hello.s</font></b>
<br>You will see some recognizable symbols and lots of assembler code.&nbsp;
To finally turn this into machine instructions use the following command:
<br><b><font color="#3333FF">cc -g -c hello.s</font></b>
<br><b><font color="#3333FF">view hello.o</font></b>
<br>This new file with suffix ".o" is called the object file. It contains
the machine instructions corresponding exactly to the mnemonic codes
<br>in the .s file. If you wish you can look at these machine codes using
one of the commands available to examine object files.
<br><b><font color="#3333FF">dis -L -t .data hello.o >hello.dis</font></b>
<br>The next stage is "linking" this binary code with libraries - use the
command:
<br><b><font color="#3333FF">cc -o hello hello.o</font></b></td>
</tr>
</table>

<p>The single command we use to compile was
<p><b><font color="#3333FF">cc -o hello hello.c</font></b>
<p>The word after the -o option is the name of the executable file (default
- "a.out"). The source file MUST have the ".c" extension.
<p><b><u>Note</u></b>: the compiler name may be bcc (Borland), gcc (GNU),
CC, or something else.
<br><b><u>Note</u></b>: 'C' compilers have option to optimize (for speed
or memory usage).
<br><b><u>Note</u></b>: here are some common compielr options:
<table BORDER=0 CELLSPACING=0 BGCOLOR="#CCFFFF" >
<tr>
<td>-c - compile only (do not link)
<br>-S - stop after making assempler code
<br>-E - stop after preprocessing stage
<br>-o file - define the output file
<br>-v - verbouse (print commands executed on STDERR, also print compiler
version, etc.)
<br>-l - to specify libraries to link
<br>-L - to specify directories to search for libraries
<br>-I - to specify directories to search for include files
<br>-static - tells compiler to include shared libraries into the executable
(thus making it larger) - even though the libraries are available (usually
in /lib) and can be linked dynamically during execution (on systems that
support dynamic linking)
<br>-shared - produce a shared object which can then be linked with other
objects&nbsp; to&nbsp; form an executable.&nbsp; Only a few systems support
this option.
<br>-symbolic - bind&nbsp; references to global symbols when building a
shared object, warn about any unresolved references - only if supported.
<br>-On, where n=0,1,2,or 3 - sets level of optimization
<br>-b machine - to specify the type of machine for which to compile
<br>-V version - to specify which version of compiler to run</td>
</tr>
</table>
there are many more options (100s) - see man pages for the compiler.
<p>=============================================================================================
<p>All information (code or data) is stored in a computer in binary formats.
<p><b><u>Data types:</u></b>
<p><b><u>Character:</u></b>
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#include &lt;stdio.h>
<br>main() {
<br>&nbsp; char a;
<br>&nbsp; unsigned char b;
<p>&nbsp; a = b = 128;
<br>&nbsp; a >>= 1;
<br>&nbsp; b >>= 1;
<br>&nbsp; printf ( "\nYour computer has %ssigned char.\n\n", a == b ?
"un" : "" );
<br>}</td>
</tr>
</table>
compile and run it - and it will print:
<br>&nbsp;&nbsp; <font color="#3333FF">Your computer has unsigned char.</font>
<p><b><u>Integers:</u></b>
<br>&nbsp; int i;
<br>&nbsp; short int smaller_number;&nbsp; /* usually 2 bytes */
<br>&nbsp; long int big_number;&nbsp;&nbsp; /* usually 4 bytes */
<p><b><u>Real Numbers:</u></b>
<p>&nbsp; float length_of_water_line;&nbsp;&nbsp;&nbsp;&nbsp; /* in meters
*/
<br>&nbsp; double displacement;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* in grammes */
<p>file <b><font color="#CC0000">/usr/include/values.h</font></b> defines
some usefule values:
<p>&nbsp; MAXFLOAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.40282346638528860e+38
<br>&nbsp; MINFLOAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.40129846432481707e-45
<br>&nbsp; MAXDOUBLE&nbsp;&nbsp;&nbsp;&nbsp; 1.79769313486231470e+308
<br>&nbsp; MINDOUBLE&nbsp;&nbsp;&nbsp;&nbsp; 4.94065645841246544e-324
<p>Practically,&nbsp; float - 6, double - 12&nbsp; significant digits.
<p><b><u>Signed and unsigned prefixes.</u></b>
<br>(for both char and integer types the declaration can be preceded by
the word "unsigned").
<p><b><u>arrays:</u></b>
<br>&nbsp; char client_surname[31];
<p>&nbsp; This declaration reserves storage for a string of 30 characters
plus the <b><font color="#CC0000">NULL</font></b> character of value zero
which terminates the string.
<p><b><u>Structures:</u></b>
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>/* Define the template for 'ship' structure type: */:
<br><font color="#3333FF">struct ship {</font>
<br><font color="#3333FF">&nbsp; char name[30];</font>
<br><font color="#3333FF">&nbsp; double displacement;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* in grammes */</font>
<br><font color="#3333FF">&nbsp; float length_of_water_line;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* in meters */</font>
<br><font color="#3333FF">&nbsp; unsigned short int number_of_passengers;</font>
<br><font color="#3333FF">&nbsp; unsigned short int number_of_crew;</font>
<br><font color="#3333FF">};</font>
<p>/* Now we can create the structure in memory: */
<br><b><font color="#3333FF">struct ship cunarder;</font></b>
<br>/* Now we can assign values: */
<br><font color="#3333FF">&nbsp; cunarder.displacement = 97500000000.0;</font>
<br><font color="#3333FF">&nbsp; cunarder.length_of_water_line = 750.0</font>
<br><font color="#3333FF">&nbsp; cunarder.number_of_passengers = 3575;</font>
<br><font color="#3333FF">&nbsp; cunarder.number_of_crew = 4592;</font></td>
</tr>
</table>

<p>Here is a short test program:
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td ALIGN=LEFT VALIGN=TOP>#include &lt;stdio.h>
<p>struct ship
<br>{
<br>&nbsp; char name[31];
<br>&nbsp; double displacement;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* in grammes */
<br>&nbsp; float length_of_water_line;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* in meters */
<br>&nbsp; unsigned short int number_of_passengers;
<br>&nbsp; unsigned short int number_of_crew;
<br>&nbsp; };
<p>char *format = "\
<br>Name of Vessel: %-30s\n\
<br>&nbsp; Displacement: %13.3f\n\
<br>&nbsp;&nbsp;&nbsp; Water Line: %5.1f\n\
<br>&nbsp;&nbsp;&nbsp; Passengers: %4d\n\
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Crew: %4d\n\n";
<p>main()
<br>{
<br>&nbsp; struct ship cunarder;
<p>&nbsp; cunarder.name = "Queen Mary";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* This is the bad line. */
<br>&nbsp; strcpy ( cunarder.name, "Queen Mary" );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* The corrected line */
<br>&nbsp; cunarder.displacement = 97500000000.0;
<br>&nbsp; cunarder.length_of_water_line = 750.0
<br>&nbsp; cunarder.number_of_passengers = 3575;
<br>&nbsp; cunarder.number_of_crew = 4592;
<p>&nbsp; printf ( format,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cunarder.name,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cunarder.displacement,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cunarder.length_of_water_line,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cunarder.number_of_passengers,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cunarder.number_of_crew
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
<br>&nbsp; }</td>
</tr>
</table>

<p>Now let's compile and execute it:
<br><b><font color="#3333FF">$ cc demo1a.c</font></b>
<br><b><font color="#3333FF">$ a.out</font></b>
<p>Name of Vessel: Queen Mary
<br>&nbsp; Displacement: 97500000000.0 grammes
<br>&nbsp;&nbsp;&nbsp; Water Line: 750.0 metres
<br>&nbsp;&nbsp;&nbsp; Passengers: 3575
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Crew: 4592
<br>&nbsp;
<p><b><u>Three special allocation methods, 'static' and 'register', and
'const':</u></b>
<br>'static' - will be placed in the main storage to live all the execution
time.
<br>'register' - tells compiler that you will be using this a lot - for
optimal storage
<br>'comst' - means constant
<p><b><u>Pointers.</u></b>
<br>pointer - a variable which contain the address of a data element.
<p><b><font color="#3333FF">char c;&nbsp; /* normal variable */</font></b>
<br><b><font color="#3333FF">char *ch_p; /* pointer to a char variable
*/</font></b>
<p>Unary operator <b><font color="#3333FF">'&amp;'</font></b> gives the
address of the variable:
<p><b><font color="#3333FF">ch_p = &amp;c;</font></b>
<p><b><u>Input/output:</u></b>
<br>"printf" - print formatted output
<br>"scanf" - read data into the program
<p>On unix use manpages to read the options.
<br><b><font color="#3333FF">man printf</font></b>
<br><b><font color="#3333FF">man scanf</font></b>
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#include &lt;stdio.h>
<p>int printf ( format [ , arg ] ... )
<br>char *format;
<p>int fprintf ( stream, format [ , arg ] ... )
<br>FILE *stream;
<br>char *format;
<p>int sprintf ( s, format [ , arg ] ... )
<br>char *s, *format;</td>
</tr>
</table>

<p>Test program:
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#include &lt;stdio.h>
<p>char *verse[] = {
<br>&nbsp; "On top of the Crumpetty Tree",
<br>&nbsp; "The Quangle Wangle sat,",
<br>&nbsp; "But his face you could not see,",
<br>&nbsp; "On account of his Beaver Hat.",
<br>&nbsp; "For his Hat was a hundred and two feet wide.",
<br>&nbsp; "With ribbons and bibbons on every side,",
<br>&nbsp; "And bells, and buttons, and loops, and lace,",
<br>&nbsp; "So that nobody ever could see the face",
<br>&nbsp; "Of the Quangle Wangle Quee.",
<br>&nbsp; NULL
<br>&nbsp; };
<p>main() {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char **ch_pp;
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* This will print the data
left justified. */
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( ch_pp = verse; *ch_pp;
ch_pp++ ) printf ( "%s\n", *ch_pp );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( "\n" );
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; This will print
the data right justified.&nbsp; */
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( ch_pp = verse; *ch_pp;
ch_pp++ )&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf
( "%79s\n", *ch_pp );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( "\n" );
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* This will centre the data.&nbsp;
*/
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( ch_pp = verse; *ch_pp;
ch_pp++ )&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int length;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
char format[10];
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
length = 40 + strlen ( *ch_pp ) / 2;&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sprintf ( format, "%%%ds\n", length );&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
printf ( format, *ch_pp );&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( "\n" );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<p>&nbsp;</td>
</tr>
</table>

<p>scanf() - family of functions used to input from the outside world,
note that&nbsp; arguments to the function are all POINTERS. The format
string has to be passed in to the function using a pointer, simply because
this is the way 'C' passes strings.
<br><a NAME="C-tutorial_part2"></a>
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" BGCOLOR="#C4ECFF" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><b>C-tutorial part 2</b></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><b><a href="index.html">home</a> - <a href="#top">top
of the page</a> - </b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<p><b><u>Arrays and Pointers.</u></b>
<br><font color="#3333FF">&nbsp; char name[30];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* An array of 30 signed characters. */</font>
<br><font color="#3333FF">&nbsp; char *strings[50];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* 50 pointers to strings. */</font>
<br><font color="#3333FF">&nbsp; unsigned long int *(*func)()[20];/* An
array of pointers to functions which */</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* return pointers to unsigned long ints. */</font>
<br><font color="#3333FF">&nbsp; struct ship *vessel_p;</font>
<br><font color="#3333FF">&nbsp; struct ship fleet[5];&nbsp;&nbsp;&nbsp;&nbsp;
/* This allocates enough storage for 5 ships' info.*/</font>
<p><font color="#3333FF">&nbsp; vessel_p = fleet; /*point at the first
vessel in the fleet.*/</font>
<br><font color="#3333FF">&nbsp; vessel_p++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* point a the next ship in the fleet array. */</font>
<br><font color="#3333FF">&nbsp; vessel_p = fleet + 3;</font>
<br><font color="#3333FF">&nbsp; i = vessel_p - fleet; /* the index of
the ship in the fleet at which we are pointing */</font>
<br><font color="#3333FF">&nbsp; d = vessel_p - another_vessel_p; /* This
gives the separation in elements. */</font>
<p>Note: the result of pointer arithmetic is ALWAYS expressed in elements
rather than bytes.
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>/* Using a pointer to reference a structure: */
<br>&nbsp; vessel_p = fleet;
<p>&nbsp; vessel_p->name = "Queen Mary";
<br>&nbsp; vessel_p->displacement = 97500000000.0;
<br>&nbsp; vessel_p->length_of_water_line = 750.0
<br>&nbsp; vessel_p->number_of_passengers = 3575;
<br>&nbsp; vessel_p->number_of_crew = 4592;</td>
</tr>
</table>
&nbsp;&nbsp; Remember:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It's a "." when accessing a struct
which is in storage declared in the program.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It's a "->" when accessing a struct
at which a pointer is pointing.
<p>&nbsp; <b><u>Initialisation of arrays.</u></b>
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>&nbsp; char *qbf = "The quick brown fox jumped over the lazy dogs back";
<p>&nbsp; int tic_tac_toe[3][3] =
<br>&nbsp; {
<br>&nbsp;&nbsp;&nbsp; { 1, 2, 3 },
<br>&nbsp;&nbsp;&nbsp; { 4, 5, 6 },
<br>&nbsp;&nbsp;&nbsp; { 7, 8, 9 }
<br>&nbsp;&nbsp;&nbsp; };
<p>&nbsp; struct ship fleet[2] =
<br>&nbsp; {
<br>&nbsp;&nbsp;&nbsp; { "Queen Elizabeth",&nbsp; 97500000000.0, 750.0,
3575, 4592 },
<br>&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Queen Mary", 115000000000.0,
875.0, 4500, 5500 }
<br>&nbsp;&nbsp;&nbsp; };
<p>char *verse[] =&nbsp;&nbsp;&nbsp; /* array of pointers */
<br>{
<br>&nbsp; "On top of the Crumpetty Tree",
<br>&nbsp; "The Quangle Wangle sat,",
<br>&nbsp; "But his face you could not see,",
<br>&nbsp; "On account of his Beaver Hat.",
<br>&nbsp; "For his Hat was a hundred and two feet wide.",
<br>&nbsp; "With ribbons and bibbons on every side,",
<br>&nbsp; "And bells, and buttons, and loops, and lace,",
<br>&nbsp; "So that nobody ever could see the face",
<br>&nbsp; "Of the Quangle Wangle Quee."
<br>&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp; /* this is to tell the compiler
that this is the end */
<br>&nbsp; };
<br>&nbsp;</td>
</tr>
</table>

<p>&nbsp;&nbsp; The other way is to calculate the size of the table by
using the <b><font color="#3333FF">sizeof</font></b>&nbsp; operator - Note
that although use of sizeof looks like a function call&nbsp; it is in fact
an intrinsic operator of the language. The result is available at compile
time. So one can say:-
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#3333FF">#define
SIZE_OF_VERSE sizeof verse</font></b>
<p><b><u>enum:</u></b>
<br><b><font color="#3333FF">enum spectrum { red, orange, yellow, green,
blue, indigo, violet } colour;</font></b>
<p>In this construct the first symbol is given the value of 0 and for each
following symbol the value is incremented.
<br>It is however possible to assign specific values to the symbols like
this:
<p><font color="#3333FF">&nbsp; enum tub</font>
<br><font color="#3333FF">&nbsp; { anorexic = 65,</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; slim = 70,</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; normal = 80,</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; fat = 95,</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; obese = 135</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; };</font>
<p>Here is another trivial program which demonstrates the use of enum and
a pre-initialised array.
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#include &lt;stdio.h>
<p>enum spectrum { red, orange, yellow, green, blue, indigo, violet } colour;
<p>char *rainbow[] = { "red", "orange", "yellow", "green",
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"blue", "indigo", "violet" };
<p>main() {
<br>&nbsp; for ( colour = red; colour &lt;= violet; colour++ ) {
<br>&nbsp;&nbsp;&nbsp; printf ( "%s ", rainbow[colour]);
<br>&nbsp;&nbsp;&nbsp; }
<br>&nbsp; printf ( "\n" );
<br>}</td>
</tr>
</table>
&nbsp;&nbsp; The output of which is:
<p><font color="#3333FF">red orange yellow green blue indigo violet</font>
<p><b><u>Yet another example program:</u></b>
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>char *ident = "@(#) tellme.c - An example of using a pointer to a function.";
<p>#include &lt;stdio.h>
<br>#include &lt;math.h>
<br>#include &lt;sys/errno.h>
<p>/*
<br>These declarations are not in fact needed as they are all declared
extern in
<br>math.h. However if you were to use routines which are not in a library
and
<br>therefore not declared in a '.h' file you should declare them. Remember
you
<br>MUST declare external routines which return a type other than the int
type.
<p>extern double&nbsp; sin ();
<br>extern double&nbsp; cos ();
<br>extern double&nbsp; tan ();
<br>extern double atof ();
<br>*/
<p>struct table_entry
<br>{
<br>&nbsp; char *name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* The address of the character string. */
<br>&nbsp; double (*function)();&nbsp;&nbsp; /* The address of the entry
point of the function. */
<br>&nbsp; };
<p>typedef struct table_entry TABLE;
<p>double help ( tp )
<br>TABLE *tp;
<br>{ printf ( "Choose one of these functions:- " );
<br>&nbsp; fflush ( stdout );
<br>&nbsp; for ( ; tp -> name; tp++ ) printf ( "%s ", tp -> name );
<br>&nbsp; printf ( "\nRemember the input is expressed in Radians\n" );
<br>&nbsp; exit ( 0 );
<br>&nbsp; return ( 0.0 );&nbsp; /* Needed to keep some nit-picking dumb
compilers happy! */
<br>&nbsp; }
<p>/*
<br>&nbsp;* This is the array of pointers to the strings and function entry
points.
<br>&nbsp;* Is is initialised at linking time. You may add as many functions
as you
<br>&nbsp;* like in here PROVIDED you declare them to be extern, either
in
some .h
<br>&nbsp;* file or explicitly.
<br>&nbsp;*/
<p>TABLE interpretation_table [ ] =
<br>{
<br>&nbsp; { "sin",&nbsp; sin&nbsp; },
<br>&nbsp; { "tan",&nbsp; tan&nbsp; },
<br>&nbsp; { "cos",&nbsp; cos&nbsp; },
<br>&nbsp; { "help", help },
<br>&nbsp; {&nbsp; NULL,&nbsp; NULL }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* To flag the end of the table. */
<br>&nbsp; };
<p>char *output_format = { "\n %s %s = %g\n" };
<br>extern int errno;
<br>extern void perror();
<p>main( argc, argv )
<br>int argc;
<br>char **argv;
<br>{
<br>&nbsp; TABLE *tp;
<br>&nbsp; double x, answer;
<p>&nbsp; if ( argc > 3 )
<br>&nbsp; {
<br>&nbsp;&nbsp;&nbsp; errno = E2BIG;
<br>&nbsp;&nbsp;&nbsp; perror ( "tellme" );
<br>&nbsp;&nbsp;&nbsp; exit ( -1 );
<br>&nbsp;&nbsp;&nbsp; }
<p>&nbsp; for (;;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* This is the way to set up a continuous loop. */
<br>&nbsp; {
<br>&nbsp;&nbsp;&nbsp; for ( tp = interpretation_table;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( tp -> name
&amp;&amp; strcmp ( tp -> name, argv[1] ));
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tp++
<br>&nbsp;&nbsp;&nbsp; )&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Note use of empty for loop to position tp. */
<p>&nbsp;&nbsp;&nbsp; if ( tp -> function == help ) (*tp -> function )(
interpretation_table );
<br>&nbsp;&nbsp;&nbsp; if ( tp -> name == NULL )
<br>&nbsp;&nbsp;&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ( "Function %s not implemented
yet\n", argv[1] );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit ( 1 );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Leave the loop. */
<br>&nbsp;&nbsp;&nbsp; }
<p>&nbsp; x = atof ( argv[2] );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Convert the character string to a double. */
<br>&nbsp; answer = ( *tp -> function )( x );/* Execute the desired function.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*/
<br>&nbsp; printf ( output_format,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Pointer
to printf()'s format string.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; argv[1],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Pointer to the name of the function.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; argv[2],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Pointer to the input number ascii string. */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Value ( in double floating point binary ) */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
<br>&nbsp; }</td>
</tr>
</table>

<p><b><u>Precedence.</u></b>
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; First up come what are called
the primary-expression operators:
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
()&nbsp;&nbsp;&nbsp; Function.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[]&nbsp;&nbsp;&nbsp; Array.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
.&nbsp;&nbsp;&nbsp;&nbsp; struct member ( variable ).
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
->&nbsp;&nbsp;&nbsp; struct member ( pointer ).
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The unary operators:
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*&nbsp;&nbsp;&nbsp;&nbsp; Indirection via a Pointer.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;&nbsp;&nbsp;&nbsp;&nbsp; Address of Variable.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&nbsp;&nbsp;&nbsp;&nbsp; Arithmetic Negative.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
!&nbsp;&nbsp;&nbsp;&nbsp; Logical Negation or Not.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
~&nbsp;&nbsp;&nbsp;&nbsp; Bit-wise One's Complement.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
++&nbsp;&nbsp;&nbsp; Increment.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
--&nbsp;&nbsp;&nbsp; Decrement.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sizeof&nbsp; Which is self explanitary.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now the binary operators:
<p>&nbsp;&nbsp; Arithmetic Operators.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*&nbsp;&nbsp;&nbsp;&nbsp; Multiply.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
My
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/&nbsp;&nbsp;&nbsp;&nbsp; Divide.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Dear
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
%&nbsp;&nbsp;&nbsp;&nbsp; Modulo, or Remainder of Integer Division.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+&nbsp;&nbsp;&nbsp;&nbsp; Addition.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Aunt
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&nbsp;&nbsp;&nbsp;&nbsp; Subtraction.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Sally
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The Shifting Operators.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
>>&nbsp;&nbsp;&nbsp; Bit-wise Shift to the Right.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt;&nbsp;&nbsp;&nbsp; Bit-wise Shift to the Left.
<p>&nbsp;&nbsp; Logical Relation Operators.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&nbsp;&nbsp;&nbsp;&nbsp; Less Than.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
>&nbsp;&nbsp;&nbsp;&nbsp; Greater Than.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;=&nbsp;&nbsp;&nbsp; Less Than or Equal.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
>=&nbsp;&nbsp;&nbsp; Greater Than or Equal.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
==&nbsp;&nbsp;&nbsp; Equal.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
!=&nbsp;&nbsp;&nbsp; Not Equal.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bit-wise Boolean Operators.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;&nbsp;&nbsp;&nbsp;&nbsp; Bit-wise And.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^&nbsp;&nbsp;&nbsp;&nbsp; Bit-wise Exclusive-Or (XOR).
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp; Bit-wise Or.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The Logical Operators.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;&amp;&nbsp;&nbsp;&nbsp; Logical And.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
||&nbsp;&nbsp;&nbsp; Logical Or.
<p>&nbsp;&nbsp; The Assignment Operators. ( They all have the same priority.
)
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
=&nbsp;&nbsp;&nbsp;&nbsp; The normal assignment operator.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The Self-referencing
Assignment Operators.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+=
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-=
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*=
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/=
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
%=
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
>>=
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&lt;=
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;=
<br>&nbsp;&nbsp;&nbsp; ^=
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|=</td>
</tr>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = 8;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a += 2;&nbsp;&nbsp;&nbsp;&nbsp;
/* The result is 10 */
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = 7;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a ^= 2;&nbsp;&nbsp;&nbsp;
/* Now a is 5 */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a ^= 2;&nbsp;&nbsp;&nbsp;
/*&nbsp; and back to 7. */
<p><b><u>Note:</u></b>&nbsp; with old compiler you may have problems that
can be cured by putting spaces on either side of the '=' sign or bracketing
the unary minus to the operand.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a=(-2);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = -2;
<p><b><u>Note:</u></b>&nbsp;&nbsp; >>&nbsp; If you shift a signed integer
to the right when the sign bit is set then in all probability the sign
will be extended.
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#include &lt;stdio.h>
<p>#define WORD_SIZE ( sizeof ( INTEGER int ) * 8 )
<br>#define NIBBLE_SIZE 4
<br>#define NIBBLES_IN_WORD (( WORD_SIZE ) / NIBBLE_SIZE )
<br>#define SIGN_BIT ( 1 &lt;&lt; ( WORD_SIZE - 1 ))
<p>char *title[] ={ "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Signed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Unsigned",
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Signed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Unsigned"
<br>&nbsp;};
<p>main () {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER int a;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned INTEGER int b,
mask;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ab, i, j, bit_counter,
line_counter;
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = b = SIGN_BIT;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ( "%s\n\n", title
[ ( WORD_SIZE == 16 ) ? 0 : 1 ] );
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( line_counter = 0; line_counter
&lt; WORD_SIZE; line_counter++ )&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for ( ab = 0; ab &lt; 2; ab++ )&nbsp;&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mask = SIGN_BIT;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for ( i = 0; i &lt; NIBBLES_IN_WORD; i++ )&nbsp;&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for ( j = 0; j &lt; NIBBLE_SIZE; j++ )&nbsp;&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
printf ( "%c", ((( ab ) ? b : a ) &amp; mask ) ? '1' : '0' );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mask >>= 1;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
printf ( " " );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
printf ( "%s", ( ab ) ? "\n" : " " );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if ( ab )&nbsp;&nbsp;&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
b >>= 1;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} else {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
a >>= 1;
<br>#if defined(FIX_COMPILER_BUG)
<br># if (INTEGER == long)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
a |= SIGN_BIT;&nbsp;&nbsp;&nbsp; /* This is a work-around for the 3b2 compiler
bug. */
<br># endif
<br>#endif
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</td>
</tr>
</table>

<p>This program may behave differently for short and long integers because
compiler issuing a Logical Shift instruction, when it should issue a Arithmetic
Shift instruction for signed integers and a Logical Shift instructon for
unsigned ones.&nbsp; Here are the compiler invocation lines.
<p><b><font color="#3333FF">cc -olong.shifts -DFIX_COMPILER_BUG -DINTEGER=long
shifts.c</font></b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and
<br><b><font color="#3333FF">cc -oshort.shifts -DINTEGER=short shifts.c</font></b>
<p>Experiment with the "-DFIX_COMPILER_BUG" and see what your compiler
does.
<br><a NAME="C-tutorial_part3"></a>
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" BGCOLOR="#C4ECFF" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><b>C-tutorial part 3</b></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><b><a href="index.html">home</a> - <a href="#top">top
of the page</a> - </b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<p><b><font color="#CC0000">The Pre-processor and Header Files.</font></b>
<p>The pre-processor is activated by a '#' character in column one of the
source code. There are several statements vis:
<p><b><font color="#3333FF">#include</font></b>
<p><b><font color="#3333FF">#define</font></b>
<br><b><font color="#3333FF">#undef</font></b>
<p><b><font color="#3333FF">#if</font></b>
<br><b><font color="#3333FF">#else</font></b>
<br><b><font color="#3333FF">#endif</font></b>
<p><b><font color="#3333FF">#ifdef</font></b>
<br><b><font color="#3333FF">#ifndef</font></b>
<p><b><font color="#3333FF">#pragma</font></b>
<p><b><font color="#3333FF">#include.</font></b>
<p>Examples:
<br><b><font color="#3333FF">#include &lt;stdio.h></font></b>
<p><b><font color="#3333FF">#if ( FLAG )</font></b>
<br><b><font color="#3333FF"># include "true.h"</font></b>
<br><b><font color="#3333FF">#else</font></b>
<br><b><font color="#3333FF"># include "false.h"</font></b>
<br><b><font color="#3333FF">#endif</font></b>
<p>If the file name is <b><font color="#3333FF">&lt; .. ></font></b> -
then it comes from /usr/include directory ( or its <b><font color="#3333FF">/sys/</font></b>&nbsp;
subdirectory ).
<br>If the file name is in <b><font color="#3333FF">" .. "</font></b> -
then it comes from the current working drectory (or you can extend search
path using command-line switches).
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>extern struct tm *gmtime(), *localtime();
<br>extern char *ctime(), *asctime();
<br>int&nbsp; cftime(),&nbsp; ascftime();
<br>extern void tzset();
<br>extern long timezone, altzone;
<br>extern int daylight;
<br>extern char *tzname[];</td>
</tr>
</table>

<p>hw_uc.h
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#define HELLO_MESSAGE "HELLO WORLD...\n";</td>
</tr>
</table>

<p>hello.c
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#include &lt;stdio.h>
<br>#include HW_H
<p>#if !defined( HELLO_MESSAGE )
<br># error "You have forgotten to define the header file name."
<br>#endif
<p>char *format = "%s",&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *hello = HELLO_MESSAGE;
<p>main() { printf ( format, hello ); }</td>
</tr>
</table>

<p><b><font color="#3333FF">cc -DHW_H="\"hw_uc.h\"" hello.c</font></b>
<p>The compiler output is placed, by default, in the file a.out, so to
execute it issue the command:
<br><b><font color="#3333FF">a.out</font></b>
<p>Which, fairly obviously, produces the output:
<br><font color="#3333FF">HELLO WORLD...</font>
<p>As we are going to generate another version of the program we had better
move the executable image file to another file name:
<br><b><font color="#3333FF">mv a.out hello_uc</font></b>
<p>Now to produce the other version issue the command line:
<br><b><font color="#3333FF">cc -DHW_H="\"hw_lc.h\"" hello.c; mv a.out
hello_lc; hello_lc</font></b>
<p>Which compiles the lower-case version of the hello.c program, using
this version of the include file:
<br>hw_lc.h
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#define HELLO_MESSAGE "Hello World...\n";</td>
</tr>
</table>
and then moves the executable image to a different file and executes it
producing this output:
<br><font color="#3333FF">Hello World...</font>
<p>commands included in a shell file:
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td># @(#) Shell file to do the compilations.
<p>cc -o hello_uc -DHW_H="\"hw_uc.h\"" hello.c
<br>cc -o hello_lc -DHW_H="\"hw_lc.h\"" hello.c</td>
</tr>
</table>

<p><b><u><font color="#3333FF">#define</font></u></b>
<br>&nbsp;- to set up macro definitions. See many exampels in<b><font color="#3333FF">
/usr/include/sys/file.h</font></b> .
<br>For example:
<p><b><font color="#3333FF">#define FAPPEND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0x08</font></b>
<br><b><font color="#3333FF">#define min(a, b) ((a&lt;b) ? a : b )</font></b>
<p><b><u>NOTE:</u></b>
<br>&nbsp; 1) There isn't a space between the last character of the symbol
being defined and the opening parenthesis enclosing the arguments, and
there MUST NOT BE one.
<br>&nbsp; 2) The code into which the macro is expanded MUST always be
enclosed in parentheses and for safety always use parentheses to get the
arithmetic right.
<br>&nbsp; 3) Never EVER define a macro, and use it with a side effect.
e.g.
<br>&nbsp; c = min ( a++, b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* DON'T _EVER_ DO THIS!!! */
<br>&nbsp;&nbsp;&nbsp;&nbsp; Do you think that the value of 'a' will get
advanced after the macro is used? Well it WON'T. It gets incremented after
the less than test and before the values get assigned! Generate the output
from the pre-processor of the code below to see what's going on:
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#include &lt;stdio.h>
<br>main() {&nbsp;
<br>&nbsp; int a,b,c;
<br>&nbsp; a = 1;
<br>&nbsp; b = 2;
<br>&nbsp; c = min ( a++, b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* DON'T _EVER_ DO THIS!!! */
<br>&nbsp; printf ( "a: %d, b: %d, c: %d\n", a, b, c );
<br>}</td>
</tr>
</table>

<p>&nbsp; 4) You can continue a macro on the next line by putting a \ (
back-slash ) as THE VERY LAST character on the line.
<br>&nbsp;
<p><b><u><font color="#3333FF">#undef:</font></u></b>
<br>&nbsp;- this preprocessor command removes a symbol WHICH IS BEING USED
BY THE PRE-PROCESSOR.
<p><b><font color="#3333FF">#if ( FLAG )</font></b>
<br><b><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Code in
here is sent on to the compiler if FLAG is true. */</font></b>
<br><b><font color="#3333FF">#else</font></b>
<br><b><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Code in
here is sent on to the compiler if FLAG is false. */</font></b>
<br><b><font color="#3333FF">#endif</font></b>
<p>You are also allowed to say:
<br><b><font color="#3333FF">#if defined( FLAG )</font></b>
<br><b><font color="#3333FF">#if !defined( FLAG )</font></b>
<p>Here is an old way of doing the same:
<br><b><font color="#3333FF">#ifdef&nbsp;&nbsp; FLAG</font></b>
<br><b><font color="#3333FF">#ifndef&nbsp;&nbsp; FLAG</font></b>
<p>By convention all pre-processor symbols are in UPPER_CASE.
<p><b><u><font color="#3333FF">#pragma</font></u></b>
<br>&nbsp; - used to alter the way in which the compiler works on a block
of code, it is implementation dependent.
<p><b><u><font color="#3333FF">The "stringizing" operator</font></u></b>
- will discuss later
<br><a NAME="C-tutorial_part4"></a>
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" BGCOLOR="#C4ECFF" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><b>C-tutorial part 4</b></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><b><a href="index.html">home</a> - <a href="#top">top
of the page</a> - </b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<p><b><u><font color="#CC0000">Libraries.</font></u></b>
<p>If the function returns a value which is other than of type int, you
have to tell the compiler the type of the returned value. For example,
if you want to use library functions <b>strcmp</b>, and <b>qsort</b>. Let's
look manpage for qsort(3C) , where the 3C in parenthesis is the cryptic
code which is the unix apology for a reference to section 3C in the Manual.&nbsp;
In SYNOPSIS there is no mention of a header file to #include, and also
notice that qsort returns a void, not an int. This means that there is
no header file <b><font color="#CC0000">/usr/include/qsort.h</font></b>&nbsp;
and you have to declare qsort yourself as an external function. Now look
manpage for string(3C) - the SYNOPSIS here includes the line #include &lt;string.h>
so you have to put it in your program text.
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#ident "@(#) qsort-demo.c"
<br>#include &lt;stdio.h>
<br>#include &lt;string.h>
<br>#include &lt;assert.h>
<p>extern void qsort ();
<br>extern int strcmp();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Some
compilers need this defined, most don't. */
<p>char names[22][25] =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Here are some names to sort. */
<br>{
<br>&nbsp; "John Nagle", "Colin Douthwaite", "Ian Lance Taylor", "Brian
J. Murrell",
<br>&nbsp; "Pete", "Geoff Mccaughan", "David Liebert", "Operator", "Bill
Baucum",
<br>&nbsp; "Victor Volkman", "Chay R Harley", "Dan Romanchik", "Larry Kollar",
<br>&nbsp; "Gaston Ormazabal", "Arijit Chandra", "Kenneth Mark Hopkinson",
<br>&nbsp; "Kerr Hatrick", "Tim Love", "Robert M. Juranitch", "Jeffrey
Micke",
<br>&nbsp; "Duong Quoc", "Jagadesh Vasudevamurthy"
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };
<p>#define NUMBER_OF_NAMES sizeof ( names ) / sizeof ( names[0] )
<p>main()
<br>{
<br>&nbsp; int i;
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ** Print the unsorted names.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ( "The Unsorted Names.\n"
);
<br>&nbsp; for ( i = 0; i &lt; NUMBER_OF_NAMES; i++ ) printf ( "%s\n",
names[i] );
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ** Print a prompt, and wait.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ( "Press RETURN to
continue: " );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fflush ( stdout );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getchar();
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ** Now apply qsort to the
arrary of character strings.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qsort (( char * ) names,
NUMBER_OF_NAMES, sizeof ( *names ), strcmp );
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert ( names[0][0] &lt;
names[1][0] );&nbsp; /* Quick check to see it's done
<br>it. */
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ** Print the sorted names.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ( "The Sorted Names.\n"
);
<br>&nbsp; for ( i = 0; i &lt; NUMBER_OF_NAMES; i++ ) printf ( "%s\n",
names[i] );
<br>&nbsp; }</td>
</tr>
</table>

<p>This example shows also that you can the name of a function (strcmp)
to another function (qsort) for execution.
<p>The 'C' compilation system will load library functions from the library
/lib/libc.a as a default. All others have to be indicated to the linking
loader by a
<br>switch on the shell interactive command line.
<p><b><font color="#3333FF">$ cc -o prog prog.c -L /usr/local/lib -lgdbm
-lmalloc</font></b>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You might use this command
line to compile and link a program which uses both the GNU gdbm data-base
manager library, which is installed in the directory /usr/local/lib, and
<b><font color="#CC0000">the
enhanced malloc library</font></b>. Note that having a #include &lt;whatever.h>
line in the source text will NOT automagically tell the linking loader
to get the functions from the appropriate library. The -lwhatever flag
on the shell command line which initiates execution of "cc" or "ld" is
the only way to tell the loader where to look for the required library.
<br>&nbsp;
<p><b><u>De-bugging Strategies.</u></b>
<p>&nbsp; 1) Document what you are going to do before (yes BEFORE) you
write any code.
<br>&nbsp; 2) Make sure that you keep each file as small as is sensible.
<br>&nbsp; 3) Always use names for the objects in your program which are
fully descriptive.
<br>&nbsp; 4) ALWAYS take great care with the layout of your code. You
may consider to always put the opening brace of ALL program structures&nbsp;
on a new line. Also if you put them in the leftmost column for structs,
enums, and initialised tables, as well as functions, then the 'find function'
keystrokes ( "[[" and "]]" ) in vi will find them as well as the functions
themselves. Make sure you have the "showmatch" facility in vi turned on.
( And watch the cursor jump when you enter the right hand brace, bracket,
or parenthesis. )
<br>&nbsp; 5) Try as hard as you can to have as few global variables as
possible. If you absolutely have to have several globals - then confine
the scope of the globals to just the one file by marking the defining declaration
"static". This stops the compiler producing a symbol which the linking
loader will make available to all the files in your source.
<br>&nbsp; 6) Never EVER put 'magic numbers' in you source code. Always
define constants in a header file with #define lines or enum statements.
<p>Here is an example:-
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#include &lt;stdio.h>
<p>enum status_input_names
<br>{
<br>&nbsp; radiator_temperature,
<br>&nbsp; oil_temperature,
<br>&nbsp; fuel_pressure,
<br>&nbsp; energy_output,
<br>&nbsp; revolutions_per_minute
<br>&nbsp; };
<p>char *stats[] =
<br>{
<br>&nbsp; "radiator_temperature",
<br>&nbsp; "oil_temperature",
<br>&nbsp; "fuel_pressure",
<br>&nbsp; "energy_output",
<br>&nbsp; "revolutions_per_minute"
<br>&nbsp; };
<p>#define NUMBER_OF_INPUTS ( sizeof ( stats ) / sizeof ( stats[0]))
<p>main()
<br>{
<br>&nbsp; enum status_input_names name;
<p>&nbsp; printf ( "Number of Inputs is: %d\n", NUMBER_OF_INPUTS );
<br>&nbsp; for ( name = radiator_temperature; name &lt; NUMBER_OF_INPUTS;
name++)
<br>&nbsp; {
<br>&nbsp;&nbsp;&nbsp; printf ( "\n%s", stats[ name ] );
<br>&nbsp;&nbsp;&nbsp; }
<br>&nbsp; printf ( "\n\n" );
<br>&nbsp; }</td>
</tr>
</table>

<p>&nbsp; Note that as a side effect we have available the meaningful symbols
radiator_temperature etc. as indices into the array of status input names
and the symbol NUMBER_OF_INPUTS available for use as a terminator in the
'for' loop. This is quite legal because sizeof is a pseudo-function and
the value is evaluated at the time of compilation and not when the program
is executed. This means that the result of the division in the macro is
calculated at the time of compilation and this result is used as a literal
in the 'for' loop.
<p>Some advice:
<br>&nbsp; 1) Don't get confused between
<br>&nbsp;&nbsp; == - the logical equality operator, and
<br>&nbsp;&nbsp; =&nbsp;&nbsp; - the assignment to a variable operator.
<p>&nbsp; 2) Make sure that you are aware of the difference between the
logical and bit operators.
<p>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This is the logical AND function.
<br>&nbsp;&nbsp;&nbsp;&nbsp; ||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This is the logical OR function.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
The result is ALWAYS either a 0 or a 1.
<p>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This is the bitwise AND function used for masks etc.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
The result is expressed in all the bits of the word.
<p>&nbsp; 3) Similarly to 2 be aware of the difference between the logical
complementation and the bitwise one's complement operators.
<p>&nbsp;&nbsp;&nbsp;&nbsp; !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This is the logical NOT operator.
<br>&nbsp;&nbsp;&nbsp;&nbsp; ~&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This is the bitwise ones complement op.
<br>&nbsp;
<p><b><u>NOTE:</u></b>&nbsp; a LOGICAL variable is said to be TRUE when
it is non-zero, and FALSE when it is zero.
<p>&nbsp; 4) Make sure that you use an editor which tells you the matching
symbol.
<p>&nbsp; Example 1.
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>function_type function_name ( a, b )
<br>type a;
<br>type b;
<br>{
<br>&nbsp; type variable_one, variable_two;
<p>&nbsp; if ( logical_expression )
<br>&nbsp; {
<br>&nbsp;&nbsp;&nbsp; variable_one = A_DEFINED_CONSTANT;
<br>&nbsp;&nbsp;&nbsp; if ( !return_value = some_function_or_other ( a,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
variable_one,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;variable_two
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
<br>&nbsp;&nbsp;&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error ( "function_name" );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit ( FAILURE );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp; else
<br>&nbsp;&nbsp;&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ( return_value + variable_two
);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; /* End of "if ( logical_expression
)" block */
<br>&nbsp; }&nbsp;&nbsp;&nbsp; /* End of function */</td>
</tr>
</table>
This layout is easy to do using vi with this initialisation script in either
the environment variable EXINIT or the file ${HOME}/.exrc:-
<p><b><font color="#3333FF">set showmode autoindent autowrite tabstop=2
shiftwidth=2 showmatch wm=1</font></b>
<p>&nbsp; Example 2.
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>void printUandG()
<br>{
<br>&nbsp; char *format =
<br>"\n\
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; User is:
%s\n\
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Group is: %s\n\n\
<br>&nbsp;Effective User is: %s\n\
<br>Effective Group is: %s\n\n";
<p>&nbsp; ( void ) fprintf ( tty,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
format,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
passwd_p->pw_name,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
group_p->gr_name,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
epasswd_p->pw_name,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
egroup_p->gr_name
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);
<br>&nbsp; }</td>
</tr>
</table>
Notice how it is possible to split up format statements with a '\' as the
last character on the line (not even space may follow it).
<p>&nbsp;- put the opening brace on a new line,
<br>&nbsp;- set the tabs to just 2 spaces
<br>&nbsp;- break long lists of argumants into several lines
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>/*
<br>&nbsp; ** Put all the cursor positions to zero.
<br>&nbsp; */
<p>&nbsp; for ( i = 0;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s[i].element_name != ( char
*) NULL &amp;&amp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s[i].element_value != (
char *) NULL;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = ( s[i].dependent_function
== NULL )
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
? s[i].next : s[i].dependent_next
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
<br>&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Note that it is the brace and NOT the&nbsp;&nbsp;&nbsp; */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* "for" which moves the indentation level. */
<br>&nbsp;&nbsp;&nbsp; s[i].cursor_position = 0;
<br>&nbsp;&nbsp;&nbsp; }
<p>&nbsp; /*
<br>&nbsp; ** Go to start of list and hop over any constants.
<br>&nbsp; */
<p>&nbsp;&nbsp;&nbsp; for ( i = edit_mode = current_element = 0;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s[i].element_value
== ( char *) NULL ;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_element
= i = s[i].next
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) continue;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Note EMPTY statement. */
<p>&nbsp; /*
<br>&nbsp; ** Loop through the elements, stopping at end of table marker,
<br>&nbsp; ** which is an element with neither a pointer to an element_name
nor
<br>&nbsp; ** one to a element_value.
<br>&nbsp; */
<p>&nbsp; while ( s[i].element_name != ( char *) NULL &amp;&amp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s[i].element_value
!= ( char *) NULL
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
<br>&nbsp; {
<br>&nbsp;&nbsp;&nbsp; int c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Varable which holds the character from the keyboard. */
<p>&nbsp;&nbsp;&nbsp; /*
<br>&nbsp;&nbsp;&nbsp; **&nbsp; Et Cetera for many lines.
<br>&nbsp;&nbsp;&nbsp; */
<p>&nbsp;&nbsp;&nbsp; }</td>
</tr>
</table>
&nbsp; Note the commenting style. The lefthand comments provide a general
overview of what is happening and the righthand ones a more detailed view.
The double stars make a good marker so it is easy to separate the code
and the comments at a glance.
<p>&nbsp; <b><u><font color="#3333FF">The null statement:</font></u></b>
<p>&nbsp;";" - a no-operation statement.
<p>&nbsp;<b><u><font color="#3333FF">The assert macro:</font></u></b>
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#ident "@(#) assert-demo.c"
<p>#include &lt;stdio.h>
<br>#include &lt;assert.h>
<p>#define TOP_ROW 10
<br>#define TOP_COL 10
<p>main()
<br>{
<br>&nbsp; int row, col;
<p>&nbsp; for ( row = 1; row &lt;= TOP_ROW; row++);
<br>&nbsp; {
<br>&nbsp;&nbsp;&nbsp; assert ( row &lt;= TOP_ROW );
<br>&nbsp;&nbsp;&nbsp; for ( col = 1; col &lt;= TOP_COL; col++ )
<br>&nbsp;&nbsp;&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert ( col &lt;= TOP_COL );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ( "%4d", row * col );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp; printf ( "\n" );
<br>&nbsp;&nbsp;&nbsp; }
<br>&nbsp; }</td>
</tr>
</table>

<p>Which produces the output:-
<br><b><font color="#3333FF">Assertion failed:&nbsp; row &lt;= TOP_ROW
, file assert-demo.c, line 15</font></b>
<br><b><font color="#3333FF">ABORT instruction (core dumped)</font></b>
<p>It does this because the varable "row" is incremented to one greater
than The value of TOP_ROW.
<p>Note two things:
<p>&nbsp; 1) The sense of the logical condition. The assert is asserted
as soon as the result of the logical condition is FALSE. Have a look at
the file <b><font color="#3333FF">/usr/include/assert</font></b>. Where
is the ";" being used as an empty program statement?
<p>&nbsp; 2) The unix operating system has dumped out an image of the executing
program for examination using a symbolic debugger. Have a play with "<b><font color="#3333FF">sdb</font></b>"
in preparation for the lesson which deals with it in more detail.
<br><a NAME="C-tutorial_part5"></a>
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" BGCOLOR="#C4ECFF" >
<tr>
<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>

<td ALIGN=LEFT><b>C-tutorial part 5</b></td>

<td ALIGN=RIGHT VALIGN=BOTTOM><b><a href="index.html">home</a> - <a href="#top">top
of the page</a> - </b></td>

<td ALIGN=LEFT WIDTH="1%"><spacer type=block width=1 height=1></td>
</tr>
</table>

<p>Looping structures:
<br>&nbsp; <b><font color="#3333FF">do ... while ( ... );</font></b>&nbsp;
/* executed at least once, there is no `until' test at the end of a loop
*/
<br>&nbsp; <b><font color="#3333FF">while ( ... ) repeated_statement;</font></b>&nbsp;
/* if false - then repeated_statement is NEVER executed */
<p>Associated with the looping structures are the control words:
<br>&nbsp; <b><font color="#3333FF">break</font></b>;&nbsp;&nbsp; - allows
you to leave a loop in the middle of a block, and
<br>&nbsp; <b><font color="#3333FF">continue</font></b>;&nbsp;&nbsp; -
allows you to re-start it from the top.
<p>Finally we must not forget the most common and useful looping construct:
<br><b><font color="#3333FF">&nbsp; for ( init; test; increment ) repeated_statement;</font></b>
<p>Some examples.
<p>&nbsp; A do loop program.
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#ident "@(#) do_demo.c - An example of the do loop"
<p>#include &lt;stdio.h>
<p>main()
<br>{
<br>&nbsp; char character;
<p>&nbsp; character = 'a';
<p>&nbsp; do printf ( "%c", character ); while ( character++ &lt; 'z' );
<br>&nbsp; printf ( "\n" );
<br>&nbsp; }
<p>&nbsp; Fairly obviously it prints:
<p>abcdefghijklmnopqrstuvwxyz
<p>&nbsp; A while loop example.
<p>#ident "@(#) while_demo.c - An example of the while loop"
<p>#include &lt;stdio.h>
<p>main()
<br>{
<br>&nbsp; char character;
<p>&nbsp; character = 'a';
<p>&nbsp; while ( character &lt;= 'z' ) printf ( "%c", character++ );
<br>&nbsp; printf ( "\n" );
<br>&nbsp; }</td>
</tr>
</table>
Its output is exactly the same as the previous example:
<p><font color="#3333FF">abcdefghijklmnopqrstuvwxyz</font>
<p>&nbsp; In this totally trivial case it is irrelevant which program structure
you use, however you should note that in the `do' program structure the
repeated statement is always executed at least once.
<br>&nbsp; A for loop example.
<p>&nbsp; The `for' looping structure.
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#ident "@(#) for_demo.c - An example of the for loop"
<p>#include &lt;stdio.h>
<p>main()
<br>{
<br>&nbsp; char character;
<p>&nbsp; for ( character = 'a'; character &lt;= 'z' ; character++ )
<br>&nbsp; {
<br>&nbsp;&nbsp;&nbsp; printf ( "%c", character );
<br>&nbsp;&nbsp;&nbsp; }
<br>&nbsp; printf ( "\n" );
<br>&nbsp; }
<br>&nbsp;</td>
</tr>
</table>
&nbsp; Surprise, Surprise!
<p><font color="#3333FF">abcdefghijklmnopqrstuvwxyz</font>
<p>&nbsp; You should be aware that in all the looping program structures,
the repeated statement can be a null statement ( either just a `;' or the
reserved word `continue;' ). This means that it is possible to - for example
- position a pointer, or count up some items of something or other. It
isn't particularly easy to think up a trivial little program which demonstrates
this concept, however the two `for' loops give some indication of the idea.
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#ident "@(#) pointer_demo.c - Pointer operations with the for loop"
<p>#include &lt;stdio.h>
<p>main()
<br>{
<br>&nbsp; char character, *character_pointer, alphabets [ 53 ];
<p>&nbsp; for ( character = 'a', character_pointer = alphabets;&nbsp; /*
Start conditions */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character &lt;= 'z';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Run while true&nbsp;&nbsp; */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *character_pointer++ = character++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* All the work&nbsp;&nbsp;&nbsp;&nbsp; */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )TRUE continue;
<p>&nbsp; for ( character = 'A';&nbsp; /* character_pointer is at the right
place already */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character &lt;= 'Z';
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *character_pointer++ = character++
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) continue;
<p>&nbsp; *character_pointer = (char) '\000'; /* NULL character to terminate
string. */
<p>&nbsp; printf ( "%s\n\n", alphabets );
<br>&nbsp; }</td>
</tr>
</table>
&nbsp; Another Surprise!
<p><font color="#3333FF">abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</font>
<br>&nbsp;
<p><b>switch</b>
<br><b>if</b>
<br><b>if ... else</b>
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>#ident "if_demo.c"
<br>#include &lt;stdio.h>
<br>main(argc, argv)
<br>int argc;
<br>char **argv;
<br>{
<br>&nbsp; if ( argc > 1 ) printf ( "You have initiated execution with
arguments."};
<br>&nbsp; }</td>
</tr>
</table>

<p>&nbsp; And the if ... else demo.
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>
<br>#ident "if_else_demo.c"
<br>/*
<br>** The Language #define could go in the compiler invocation line if
desired.
<br>*/
<p>#define ENGLISH
<p>#include &lt;stdio.h>
<p>/*
<br>** The message and text fragments output by the program.
<br>*/
<p>char *messages[] =
<br>{
<br>#if defined( ENGLISH )
<br>#ident "@(#)ENGLISH Version"
<br>&nbsp; "\nUsage: if_else_demo &lt;numeric argument 1> &lt;numeric argument
2>\n\n",
<br>&nbsp; "The first argument is ",
<br>&nbsp; "the second",
<br>&nbsp; "equal to ",
<br>&nbsp; "bigger than ",
<br>&nbsp; "smaller than "
<br>#endif
<p>#if defined( FRANCAIS )
<br>#ident "@(#)FRENCH Version"
<p>&nbsp; put the French translation in here so that we are ready to export
to
<br>&nbsp; French speaking Countries. I'd be grateful if a French speaker
could
<br>&nbsp; make the translation for me.
<p>#endif
<br>&nbsp; };
<p>/*
<br>** Meaningful words defined to constants
<br>*/
<p>#define USAGE 0
<br>#define FIRST 1
<br>#define SECOND 2
<br>#define EQUAL 3
<br>#define BIGGER 4
<br>#define SMALLER 5
<p>#define SUCCESS 0
<br>#define FAILURE 1
<p>/*
<br>** We need this more than once so it can be put in a function.
<br>*/
<p>void usage()
<br>{
<br>&nbsp; printf ( messages[USAGE]);
<br>&nbsp; exit ( FAILURE );
<br>&nbsp; }
<p>/*
<br>** Main program function starts here. ( At the top of a page no less!
)
<br>*/
<p>int main ( argc, argv )
<br>int argc;
<br>char **argv;
<br>{
<br>&nbsp; int message_index;
<br>&nbsp; double i, j, strtod();
<br>&nbsp; char *ptr;
<p>&nbsp; if ( argc != 3 ) usage();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* have we been given the right */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* number of arguments. */
<br>&nbsp; i = strtod ( argv[1], &amp;ptr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Convert to a double float. */
<br>&nbsp; if ( ptr == argv[1] ) usage();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Successful conversion? */
<br>&nbsp; j = strtod ( argv[2], &amp;ptr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Convert to a double float. */
<br>&nbsp; if ( ptr == argv[2] ) usage();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Successful conversion? */
<p>/*
<br>** This statement uses the "ternary conditional assignment" language
<br>** construction to assign the value required to the message indexing
variable.
<br>** Note that this concept is efficient in both the generation of machine
code
<br>** output ( compile the program with a -S switch and have a look )
and in the
<br>** ease with which it can be understood. The assignment is obvious
instead of
<br>** being buried under a litter of `if' and `else' keywords.
<br>*/
<p>&nbsp; message_index = ( i == j ) ? EQUAL : ( i > j ) ? BIGGER : SMALLER;
<p>/*
<br>** Now print the message.
<br>*/
<p>&nbsp; (void) printf ( "\n%s%s%s\n\n",&nbsp;&nbsp;&nbsp;&nbsp; /* Format
string specifying 3 strings. */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
messages[ FIRST ],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* Address of string. */
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
messages[ message_index ],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ditto.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*/
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
messages[ SECOND ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ditto.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*/
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);
<br>&nbsp; return ( SUCCESS );
<br>&nbsp; }</td>
</tr>
</table>
&nbsp; Well as you can no doubt gather it simply compares two numbers on
the command line and ejects a little message depending on the relative
magnitude of the numbers. In the UNIX tradition the help message is perhaps
somewhat
<br>terse, but it serves the purpose of getting you - the student - to
think about the importance of creating programs which always cope with
nonsensical input in a civilised way. Here are the lines of output.
<p><font color="#3333FF">Usage: if_else_demo &lt;numeric argument 1> &lt;numeric
argument 2></font>
<br><font color="#3333FF">The first argument is equal to the second</font>
<br><font color="#3333FF">The first argument is smaller than the second</font>
<br><font color="#3333FF">The first argument is bigger than the second</font>
<p>&nbsp; Now that the international community is shrinking with vastly
improved telecommunications, it is perhaps a good idea to think carefully
about creating programs which can talk in many languages to the users.
The method of choice is - I believe - that presented above. The #if defined(
LANGUAGE ) gives us an easy method of changing the source code to suit
the new sales area. Another possibility is to put all the text output needed
from a program into a file. The file would have to have a defined layout
and some consistent way of `getting at' the message strings.
<p>&nbsp; From a commercial point of view this may or may not be a good
business plan. Quite definitely it is an absolute no no to scatter a mass
of string literals containing the messages and message fragments all over
your program script.
<p>&nbsp; There are two more methods of altering the program flow.
<p>&nbsp; 1 ) The goto a label.
<br>&nbsp; 2 ) The setjump / longjmp library routines.
<p>&nbsp; The concept of the go to a label construction has had reams of
literary verbiage written about it and this author does not intend to add
to the pile. Suffice it to say that a goto is a necessary language construct.
There are a few situations which require the language to have ( in practice
) some form of unconditional jump. Treat this statement with great caution
if you wish your code to be readable by others. An example of legitimate
use.
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>&nbsp; for ( a = 0; a &lt; MATRIX_SIZE; a++ )
<br>&nbsp; {
<br>&nbsp;&nbsp;&nbsp; for ( b = 0; b &lt; MATRIX_SIZE; b++ )
<br>&nbsp;&nbsp;&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( process ( matrix, a, b )) goto
bad_matrix;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp; return ( OK );
<p>bad_matrix:
<p>&nbsp;&nbsp; perror ( progname, "The data in the matrix seems to have
been corrupted" );
<br>&nbsp;&nbsp; return ( BAD );</td>
</tr>
</table>

<p>&nbsp;This is one of the very few "legitimate" uses of goto, as there
is no "break_to_outer_loop" in `C'. Note that some compilers complain if
the label is not immediately followed by a statement. If your compiler
is one of these naughty ones, you can put either a `;' or a pair of braces
`{}' after the `:' as a null statement.
<p>&nbsp; An example of a program package which makes extensive use of
the goto is the rz and sz modem communications protocol implementation
by Chuck Forsberg of Omen Technology. You should download it and study
the code, but do remember that the proof of the pudding argument must apply
as the rz &amp; sz system has become extremely popular in its application
because it works so well.
<p>&nbsp; The other method of changing program flow is the setjump and
longjmp pair of library functions. The idea is to provide a method of recovery
from errors which might be detected anywhere within a large program - perhaps
a compiler, interpreter or large data acquisition system. Here is the trivial
example:
<br>&nbsp;
<table BORDER=0 CELLSPACING=0 CELLPADDING=3 BGCOLOR="#99FF99" >
<tr>
<td>
<br>#ident "set_jmp_demo.c"
<p>#include &lt;stdio.h>
<br>#include &lt;setjmp.h>
<p>jmp_buf save;
<p>main()
<br>{
<br>&nbsp; char c;
<p>&nbsp; for ( ;; )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* This is how you set up a continuous loop.
<br>*/
<br>&nbsp; {
<br>&nbsp;&nbsp;&nbsp; switch ( setjmp( save ))
<br>&nbsp;&nbsp;&nbsp; {
<br>case 0:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ( "We get a zero returned from
setjmp on setup.\n\n");
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* This is the result from setting up. */
<p>case 1:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ( "NORMAL PROGRAM OPERATION\n\n"
);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
<p>case 2:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ( "WARNING\n\n" );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
<p>case 3:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ( "FATAL ERROR PROGRAM TERMINATED\n\nReally
Terminate? y/n: " );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fflush ( stdout );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scanf ( "%1s", &amp;c );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = tolower ( c );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( c == 'y' ) return ( 1 );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ( "\n" );
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
<p>default:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ( "Should never return here.\n"
);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp; process ();
<br>&nbsp;&nbsp;&nbsp; }
<br>&nbsp; }
<p>process ()
<br>{
<br>&nbsp; int i;
<p>&nbsp; printf ( "Input a number to simulate an error condition: " );
<br>&nbsp; fflush ( stdout );
<br>&nbsp; scanf ( "%d", &amp;i );
<br>&nbsp; i %= 3;
<br>&nbsp; i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* So that we call longjmp with&nbsp; 0 &lt; i &lt; 4 */
<br>&nbsp; longjmp ( save, i);
<br>&nbsp; }</td>
</tr>
</table>

<p>&nbsp; Although in this silly little demo the call to longjmp is in
the same file as the call to setjmp, this does not have to be the case,
and in the practical situation the call to longjmp will be a long way from
the call to setjmp. The mechanism is that setjmp saves the entire state
of the computer's CPU in a buffer declared in the jmp_buf save; statement
and longjmp restores it exactly with the exception of the register which
carries the return value from longjmp. This value is the same as the second
argument in the longjmp call - i in our little demo. This means, of course,
that the stack and frame pointer registers are reset to the old values
and all the local variables being used at the time of the longjmp call
are going to be lost forever. One consequence of this is that any pointer
to memory allocated from the heap will also be lost, and you will be unable
to access the data stored in the buffer. This is what the jargonauts call
"memory leakage", and is really very difficult bug to find. Your program
runs out of dynamic memory long before it should. Take care. <b><i><u><font color="#CC0000">So
you have to keep a record of the buffers' addresses and free them before
the call to longjmp.</font></u></i></b>
<p>More details later on when we learn about the heap memory allocation
routines.
<br>----
<br>&nbsp;
</body>
</html>
